task.spawn(function()

local rs = game:GetService("RunService")
local tweens = game:GetService("TweenService")
Pl =  game.Players.LocalPlayer
Player = Pl
C = Pl.Character
Hum = C:WaitForChild("Humanoid",3)
CFR = CFrame.new

local plr = C

rad = math.rad;
cos = math.cos;
sin = math.sin;
tan = math.tan;
pi = math.pi;
cosh = math.cosh;
sinh = math.sinh;
local LerpFactor, Alpha = .1,.1
sine = 0
sine2 = 25
sine3 = 50
change = 1

-- Animate has now Ceased -- //

-- Limb Setup. --
local char = C







hed = char:WaitForChild("Head")
local Torso = char:WaitForChild("Torso")
local rarm = char:WaitForChild("Right Arm")
local larm = char:WaitForChild("Left Arm")
local lleg = char:WaitForChild("Left Leg")
local rleg = char:WaitForChild("Right Leg")
ra = char["Right Arm"]
la = char["Left Arm"]
rl = char["Right Leg"]
ll = char["Left Leg"]
LS=Torso:WaitForChild("Left Shoulder") 
RS=Torso:WaitForChild("Right Shoulder")
LH=Torso:WaitForChild("Left Hip")
RH=Torso:WaitForChild("Right Hip")

euler = CFrame.fromEulerAnglesXYZ
cf = CFrame.new
angles = CFrame.Angles
necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
RootPart=char.HumanoidRootPart
RootJoint=RootPart.RootJoint
RootCF=euler(-1.57,0,3.14)
local root = char:FindFirstChild'HumanoidRootPart'
player=Player 
ch=char
-- 
RS.Name="Right Shoulder"
RS.Part0=ch.Torso 
RS.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5) 
RS.C1=cf(0, 0.5, 0) 
RS.Part1=ch["Right Arm"] 
RS.Parent=ch.Torso 
-- 
LS.Name="Left Shoulder"
LS.Part0=ch.Torso 
LS.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8) 
LS.C1=cf(0, 0.5, 0) 
LS.Part1=ch["Left Arm"] 
LS.Parent=ch.Torso 
-- CFrame End --

local core,coreweld,penta,cyli,double,dupli,cog
local w1w,w2w,w3w,w4w,w5w,w6w,w7w,w8w,w9w,w10w,w11w,w12w
local wing1,wing2,wing3,wing4,wing5,wing6,wing7,wing8,wing9,wing10,wing11,wing12
local plr = game.Players.LocalPlayer.Character
local wingstyle = plr:WaitForChild("Values"):WaitForChild("WingStyle")
local anim = plr:WaitForChild("Values"):WaitForChild("Anim")
local fury = plr:WaitForChild("Values"):WaitForChild("Fury")
local height = 0
coroutine.resume(coroutine.create(function()
	rs.RenderStepped:Connect(function()
		C = game.Players.LocalPlayer.Character
		plr = C

		char = C
		if char ~= nil then
			if char:FindFirstChild("Torso") then
				Torso = char.Torso
			end
			local lar = char:FindFirstChild("Left Arm")
			if lar then
				larm = char["Left Arm"]
				la = char["Left Arm"]
			else
				Instance.new("Part",char).Name = "Left Arm"
			end
			local rar = char:FindFirstChild("Right Arm")
			if rar then
				rarm = char["Right Arm"]
				ra = char["Right Arm"]
			else
				Instance.new("Part",char).Name = "Right Arm"
			end
			if char:FindFirstChild("Left Leg") and char:FindFirstChild("Right Leg") then
				lleg = char["Left Leg"]
				rleg = char["Right Leg"]
				rl = char["Right Leg"]
				ll = char["Left Leg"]
			end
		end
		
		if plr then
			wing1,wing2,wing3,wing4,wing5,wing6,wing7,wing8,wing9,wing10,wing11,wing12 = plr:WaitForChild("Wing1",99999),plr:WaitForChild("Wing2"),plr:WaitForChild("Wing3"),plr:WaitForChild("Wing4"),plr:WaitForChild("Wing5"),plr:WaitForChild("Wing6"),plr:WaitForChild("Wing7"),plr:WaitForChild("Wing8"),plr:WaitForChild("Wing9"),plr:WaitForChild("Wing10"),plr:WaitForChild("Wing11"),plr:WaitForChild("Wing12")
			w1w,w2w,w3w,w4w,w5w,w6w,w7w,w8w,w9w,w10w,w11w,w12w = wing1:WaitForChild("Motor1",99999),wing2:WaitForChild("Motor2"),wing3:WaitForChild("Motor3"),wing4:WaitForChild("Motor4"),wing5:WaitForChild("Motor5"),wing6:WaitForChild("Motor6"),wing7:WaitForChild("Motor7"),wing8:WaitForChild("Motor8"),wing9:WaitForChild("Motor9"),wing10:WaitForChild("Motor10"),wing11:WaitForChild("Motor11"),wing12:WaitForChild("Motor12")
			wingstyle = plr.Values:WaitForChild("WingStyle")
			anim = plr.Values:WaitForChild("Anim")
			fury = plr.Values:WaitForChild("Fury")
			core = plr:WaitForChild("Core")
			if core then
				coreweld,penta,cyli,double,dupli,cog = core:WaitForChild("CoreWeld"),core:WaitForChild("Penta"),core:WaitForChild("Cyli"),core:WaitForChild("Double"),core:WaitForChild("Dupli"),core:WaitForChild("Cog")
			end
		end
	end)
end))

if not wing1 then
	repeat
		wait()
	until wing1
end
if wing1 then
	wing1.Primary.Changed:Connect(function(c)
		if c == "Color" then
			local p = wing1.Primary.Color
			local s = wing1.Secondary.Color
			for i,v in pairs({wing2,wing3,wing4,wing5,wing6}) do
				v.Primary.Color = p
				v.Secondary.Color = s
				v.Spin.Color = p
				v.Primary.PointLight.Color = p
				v.Particle["0"].Main.Color = ColorSequence.new(p)
				v.Particle["0"].Secondary.Color = ColorSequence.new(p)
				v.Particle["0"].Shine.Color = ColorSequence.new(p)
				v.Trail.Color = ColorSequence.new(p)

				v.Primary.Main.Color = ColorSequence.new(p)
				v.Secondary.Main.Color = ColorSequence.new(s)
				v.Particle["0"].Circle.Color = ColorSequence.new(p)
			end
			if wing7.Primary.Transparency == 0 then
				for i,v in pairs({wing7,wing8,wing9,wing10,wing11,wing12}) do
					local p = wing1.Primary.Color
					local s = wing1.Secondary.Color
					v.Primary.Color = p
					v.Secondary.Color = s
					v.Spin.Color = p
					v.Primary.PointLight.Color = p
					v.Particle["0"].Main.Color = ColorSequence.new(p)
					v.Particle["0"].Secondary.Color = ColorSequence.new(p)
					v.Particle["0"].Shine.Color = ColorSequence.new(p)
					v.Trail.Color = ColorSequence.new(p)

					v.Primary.Main.Color = ColorSequence.new(p)
					v.Secondary.Main.Color = ColorSequence.new(s)
					v.Particle["0"].Circle.Color = ColorSequence.new(p)
				end
			end
			for i,v in ipairs({wing1,wing2,wing3,wing4,wing5,wing6,wing7,wing8,wing9,wing10,wing11,wing12}) do
				v.Beam.Color = ColorSequence.new(v.Primary.Color)
				v.Particle["0"].CFrame *= CFrame.Angles(math.rad(1+1*math.cos(sine/i)),math.rad(1.2+1.4*math.cos(sine/i)),math.rad(1.4+1.2*math.cos(sine/i)))
				v.Beam.CurveSize0 = 1*math.cos(sine/13+i)
				v.Beam.CurveSize1 = -1*math.cos(sine/15+i)
			end
		end
	end)
end

-- Artificial Heartbeat --
local ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"

script:WaitForChild("Heartbeat")

local tf = 0
local allowframeloss = false
local tossremainder = false
local lastframe = tick()
local frame = 1/60
ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:wait()
	else
		for i = 0, num do
			ArtificialHB.Event:wait()
		end
	end
end

-- Start of Loops --
coroutine.resume(coroutine.create(function()
	while true do
		swait()
		sine += change
		sine2 += change
		sine3 += change
	end
end))
-- End of Loops --

-- Final Functions and variables --
function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
	return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) 
end 
local Anim="Idle"
-- Final Functions and variables end --

vpower = 1
local w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
local ap = 5*vpower
local p = .3

function cs(a)
	return(math.cos(sine/a))
end
function tw(frequency)
	local twitch = 0
	local x = math.random(1,frequency)
	if x == 1 then
		local y = math.random(1,2)
		if y == 1 then twitch = 1 else twitch = -1
		end
	end
	return(twitch)
end

local d = workspace:WaitForChild("LastStarMouseIgnore")
local leftlegheight,rightlegheight = 0,0

-- Final Loop
local coredistance = 1.5
while true do
	swait()
	if wing1 then
		local s = wing1.Secondary.Color
		local p = wing1.Primary.Color
		if core then
			if core:FindFirstChild("Base") then
				core.Base.Cyli.Color = s
				core.Base.Double.Color = p
				core.Base.Dupli.Color = p
				core.Base.Penta.Color = p
				core.Base.Cog.Color = s
				core.Base.Cyli.Centre.Particle.Color = ColorSequence.new(p)
				for i,v in pairs(core:GetDescendants()) do
					if v:IsA("Trail") then
						v.Color = ColorSequence.new(p)
					end
				end
			end
		end
	end
	if not plr then break end
	local humanoid = plr.Humanoid
	if humanoid.Health <= 0 then return end
	plr:WaitForChild("HumanoidRootPart",99999)
	local rootpart = plr.HumanoidRootPart
	local Walking = humanoid.MoveDirection.magnitude>0

	local vt = Vector3.new

	local FwdDir = (Walking and humanoid.MoveDirection*rootpart.CFrame.lookVector or vt())
	local RigDir = (Walking and humanoid.MoveDirection*rootpart.CFrame.rightVector or vt())

	local Vec = {
		X=RigDir.X+RigDir.Z,
		Z=FwdDir.X+FwdDir.Z
	};
	local Divide = 1
	if(Vec.Z<0)then
		Divide=math.clamp(-(1.25*Vec.Z),1,2)
	end
	Vec.Z = Vec.Z/Divide
	Vec.X = Vec.X/Divide

	local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude
	local velderp=RootPart.Velocity.y
	hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,char)
	local Yvel = math.clamp(.5*root.Velocity.Y,-50,50)*vpower
	local shake = 0
	if fury.Value == true then
		shake = 1
	end
	function g()
		return(cf((math.random(-20,20)/30)*shake,(math.random(-20,20)/30)*shake,(math.random(-20,20)/30)*shake)*angles(math.rad((math.random(-20,20)/30)*shake),math.rad((math.random(-20,20)/30)*shake),math.rad((math.random(-20,20)/30)*shake)))
	end
	function furyshake()
		return(angles(math.rad((math.random(-120,120)/30)*shake),math.rad((math.random(-120,120)/30)*shake),math.rad((math.random(-120,120)/30)*shake)))
	end
	local a1,a2,a3,a4,a5,a6 = g(),g(),g(),g(),g(),g()
	local wing1offset = a1*cf(p*math.cos(sine/w1o),p*math.cos(sine/w1o+(w1o/6)),p*math.cos(sine/w1o+(w1o/3)))*angles(math.rad(ap*math.cos(sine/w1o+(w1o/4))),math.rad(-20*Vec.Z*vpower+ap*math.cos(sine/w1o+(w1o/7))),math.rad(-Yvel+ap*math.cos(sine/w1o+(w1o/2))))
	local wing2offset = a2*cf(p*math.cos(sine/w2o),p*math.cos(sine/w1o+(w2o/6)),p*math.cos(sine/w2o+(w2o/3)))*angles(math.rad(ap*math.cos(sine/w2o+(w2o/4))),math.rad(-20*Vec.Z*vpower+ap*math.cos(sine/w2o+(w2o/7))),math.rad(-Yvel+ap*math.cos(sine/w2o+(w2o/2))))
	local wing3offset = a3*cf(p*math.cos(sine/w3o),p*math.cos(sine/w1o+(w3o/6)),p*math.cos(sine/w3o+(w3o/3)))*angles(math.rad(ap*math.cos(sine/w3o+(w3o/4))),math.rad(-20*Vec.Z*vpower+ap*math.cos(sine/w3o+(w3o/7))),math.rad(-Yvel+ap*math.cos(sine/w3o+(w3o/2))))
	local wing4offset = a4*cf(p*math.cos(sine/w4o),p*math.cos(sine/w1o+(w4o/6)),p*math.cos(sine/w4o+(w4o/3)))*angles(math.rad(ap*math.cos(sine/w4o+(w4o/4))),math.rad(20*Vec.Z*vpower+ap*math.cos(sine/w4o+(w4o/7))),math.rad(Yvel+ap*math.cos(sine/w4o+(w4o/2))))
	local wing5offset = a5*cf(p*math.cos(sine/w5o),p*math.cos(sine/w1o+(w5o/6)),p*math.cos(sine/w5o+(w5o/3)))*angles(math.rad(ap*math.cos(sine/w5o+(w5o/4))),math.rad(20*Vec.Z*vpower+ap*math.cos(sine/w5o+(w5o/7))),math.rad(Yvel+ap*math.cos(sine/w5o+(w5o/2))))
	local wing6offset = a6*cf(p*math.cos(sine/w6o),p*math.cos(sine/w1o+(w6o/6)),p*math.cos(sine/w6o+(w6o/3)))*angles(math.rad(ap*math.cos(sine/w6o+(w6o/4))),math.rad(20*Vec.Z*vpower+ap*math.cos(sine/w6o+(w6o/7))),math.rad(Yvel+ap*math.cos(sine/w6o+(w6o/2))))
	
	root:WaitForChild("Theme")
	if wing1 ~= nil then
		if wing1:FindFirstChild("Core") then
			if wing1.Core:FindFirstChild("Spin") then
				wing1.Core.Spin.C0 = wing1.Core.Spin.C0*CFrame.Angles(0,0,math.rad(-7*(root.Theme.Volume*10/15)*(root.Theme.PlaybackLoudness/150)))
				wing2.Core.Spin.C0 = wing2.Core.Spin.C0*CFrame.Angles(0,0,math.rad(-7*(root.Theme.Volume*10/15)*(root.Theme.PlaybackLoudness/150)))
				wing3.Core.Spin.C0 = wing3.Core.Spin.C0*CFrame.Angles(0,0,math.rad(-7*(root.Theme.Volume*10/15)*(root.Theme.PlaybackLoudness/150)))
				wing4.Core.Spin.C0 = wing4.Core.Spin.C0*CFrame.Angles(0,0,math.rad(7*(root.Theme.Volume*10/15)*(root.Theme.PlaybackLoudness/150)))
				wing5.Core.Spin.C0 = wing5.Core.Spin.C0*CFrame.Angles(0,0,math.rad(7*(root.Theme.Volume*10/15)*(root.Theme.PlaybackLoudness/150)))
				wing6.Core.Spin.C0 = wing6.Core.Spin.C0*CFrame.Angles(0,0,math.rad(7*(root.Theme.Volume*10/15)*(root.Theme.PlaybackLoudness/150)))
			end
		end
	end
	if core then
		local volume = (root.Theme.Volume*10/15)*(root.Theme.PlaybackLoudness/150)
		local offset = cf(.3*cs(30.5),.3*cs(37.4),-coredistance+.3*cs(33.6))*angles(math.rad(2*cs(26.5)),math.rad(2*cs(28.3)),math.rad(2*cs(20.1)))
		coreweld.C0 = coreweld.C0:Lerp(offset,.02)
		penta.C0 = penta.C0*angles(0,0,math.rad(-4*volume))
		double.C0 = double.C0*angles(0,0,math.rad(6*volume))
		dupli.C0 = dupli.C0*angles(0,0,math.rad(-2*volume))
		cog.C0 = cog.C0*angles(0,0,math.rad(3*volume))
		cyli.C0 = cyli.C0*angles(0,0,math.rad(-1.75))
	end
	if hed:FindFirstChild("NameGui") then
		for y,x in pairs({hed.NameGui.LowerHalf.Vis1,hed.NameGui.LowerHalf.Vis2,hed.NameGui.LowerHalf.Vis3,hed.NameGui.LowerHalf.Vis4,hed.NameGui.LowerHalf.Vis5,hed.NameGui.LowerHalf.Vis6,hed.NameGui.LowerHalf.Vis7,hed.NameGui.LowerHalf.Vis8,hed.NameGui.LowerHalf.Vis9}) do
			x.Size = x.Size:Lerp(UDim2.new(0.045,0,math.clamp(0.7*(root.Theme.Volume*10/15)*(root.Theme.PlaybackLoudness/200)*math.random(90,110)/100,0,2),0),.5)
		end
		if fury.Value == true then
			local ft = {"Arcade","Antique","SciFi","Bodoni","Garamond","Oswald","Arial","Bangers","Cartoon","Code","Creepster","DenkOne","Fantasy","Fondamento","FredokaOne","GothamSemibold","GrenzeGotisch","Highway","IndieFlower","JosefinSans","Jura","Kalam","LuckiestGuy","Merriweather","Michroma","Nunito","PatrickHand","PermanentMarker","RobotoMono","Sarpanch","SourceSansSemibold","SpecialElite","Ubuntu","TitilliumWeb"}
			hed.NameGui.LowerHalf.FormName.Font = ft[math.random(1,#ft)]
			local l,a,s,t,r = {"L","L","_"},{"A","A","_"},{"S","S","_"},{"T","T","_"},{"R","R","_"}
			local funny = {"WORTHLESS","MEANINGLESS","POINTLESS","WHO★CARES?","FUTILE","FINAL★STAR","LAST★STAR?","FIRST★STAR","LAST★STAR",l[math.random(1,3)]..a[math.random(1,3)]..s[math.random(1,3)]..t[math.random(1,3)].."★"..s[math.random(1,3)]..t[math.random(1,3)]..a[math.random(1,3)]..r[math.random(1,3)]}
			local player = {string.upper(plr.Name),string.lower(plr.Name),"NOBODY","NO ONE","SOMEONE?"}
			hed.NameGui.LowerHalf.ScriptName.Text = funny[math.random(1,#funny)].." // "..player[math.random(1,5)]
		end
	end
	local Rray,Lray = Ray.new(rl.Position,rl.CFrame.UpVector.Unit*-2),Ray.new(ll.Position,ll.CFrame.UpVector.Unit*-2)
	local rp,Rpos = workspace:FindPartOnRayWithIgnoreList(Rray,{plr,d},false,true)
	local lp,Lpos = workspace:FindPartOnRayWithIgnoreList(Lray,{plr,d},false,true)
	leftlegheight,rightlegheight = 0,0
	if rp then   rightlegheight = (rl.Position-Rpos).Magnitude-.95   end
	if lp then   leftlegheight = (ll.Position-Lpos).Magnitude-.95   end
	if w1w ~= nil then
		if wingstyle.Value == "APEX" then
			vpower = 1
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(wing1offset*cf(1.5,-1.25+.25*math.cos(sine/30),1)*angles(0,0,math.rad(60+20*math.cos(sine/30))),lerp)
			w2w.C0 = w2w.C0:lerp(wing2offset*cf(2,0,1)*angles(0,0,math.rad(90)),lerp)
			w3w.C0 = w3w.C0:lerp(wing3offset*cf(1.5,1.25-.25*math.cos(sine/30),1)*angles(0,0,math.rad(120-20*math.cos(sine/30))),lerp)
			w4w.C0 = w4w.C0:lerp(wing4offset*cf(-1.5,-1.25+.25*math.cos(sine/30),1)*angles(0,0,math.rad(-60-20*math.cos(sine/30))),lerp)
			w5w.C0 = w5w.C0:lerp(wing5offset*cf(-2,0,1)*angles(0,0,math.rad(-90)),lerp)
			w6w.C0 = w6w.C0:lerp(wing6offset*cf(-1.5,1.25-.25*math.cos(sine/30),1)*angles(0,0,math.rad(-120+20*math.cos(sine/30))),lerp)
			height = 0
			coredistance = 1.5
		elseif wingstyle.Value == "PERDURANCE" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(wing1offset*cf(0,0,1)*angles(0,0,math.rad(0+3600*math.cos(sine/400))),lerp)
			w2w.C0 = w2w.C0:lerp(wing2offset*cf(0,0,1)*angles(0,0,math.rad(72+3600*math.cos(sine/400))),lerp)
			w3w.C0 = w3w.C0:lerp(wing3offset*cf(0,0,1)*angles(0,0,math.rad(144+3600*math.cos(sine/400))),lerp)
			w4w.C0 = w4w.C0:lerp(wing4offset*cf(0,0,1)*angles(0,0,math.rad(216+3600*math.cos(sine/400))),lerp)
			w5w.C0 = w5w.C0:lerp(wing5offset*cf(0,0,1)*angles(0,0,math.rad(288+3600*math.cos(sine/400))),lerp)
			w6w.C0 = w6w.C0:lerp(wing6offset*cf(0,0,3)*angles(0,0,math.rad(-1800*math.cos(sine/400))),lerp)
			height = 2+1*cs(57)
			coredistance = 2
		elseif wingstyle.Value == "REPRESSION" then
			vpower = 1
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(wing1offset*cf(1.5,-1.25+.25*math.cos(sine/30),1)*angles(0,0,math.rad(60+20*math.cos(sine/30))),lerp)
			w2w.C0 = w2w.C0:lerp(wing2offset*cf(20,0,1)*angles(0,0,math.rad(-90)),lerp)
			w3w.C0 = w3w.C0:lerp(wing3offset*cf(1.5,1.25-.25*math.cos(sine/30),1)*angles(0,0,math.rad(120-20*math.cos(sine/30))),lerp)
			w4w.C0 = w4w.C0:lerp(wing4offset*cf(-1.5,-1.25+.25*math.cos(sine/30),1)*angles(0,0,math.rad(-60-20*math.cos(sine/30))),lerp)
			w5w.C0 = w5w.C0:lerp(wing5offset*cf(-20,0,1)*angles(0,0,math.rad(90)),lerp)
			w6w.C0 = w6w.C0:lerp(wing6offset*cf(-1.5,1.25-.25*math.cos(sine/30),1)*angles(0,0,math.rad(-120+20*math.cos(sine/30))),lerp)
			height = 0
			coredistance = 1.5
		elseif wingstyle.Value == "EXECUTION" or wingstyle.Value == "ANARCHY" then
			vpower = 1
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(wing1offset*cf(2,1,1)*angles(0,0,math.rad(10+10*math.cos(sine/40))),lerp)
			w2w.C0 = w2w.C0:lerp(wing2offset*cf(5,1.6+.4*math.cos(sine2/40),1)*angles(0,0,math.rad(30+20*math.cos(sine2/40))),lerp)
			w3w.C0 = w3w.C0:lerp(wing3offset*cf(7,3.5+1.25*math.cos(sine3/40),1)*angles(0,0,math.rad(50+40*math.cos(sine3/40))),lerp)
			w4w.C0 = w4w.C0:lerp(wing4offset*cf(-2,1,1)*angles(0,0,math.rad(-10-10*math.cos(sine/40))),lerp)
			w5w.C0 = w5w.C0:lerp(wing5offset*cf(-5,1.6+.4*math.cos(sine2/40),1)*angles(0,0,math.rad(-30-20*math.cos(sine2/40))),lerp)
			w6w.C0 = w6w.C0:lerp(wing6offset*cf(-7,3.5+1.25*math.cos(sine3/40),1)*angles(0,0,math.rad(-50-40*math.cos(sine3/40))),lerp)
			height = 5-1*math.cos(sine/40)
			coredistance = 1.5
		elseif wingstyle.Value == "VINDICTIVE" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(wing1offset*angles(0,0,math.rad(0+3600*math.cos(sine/800)))*cf(0,-5,1)*angles(0,0,math.rad(60)),lerp)
			w2w.C0 = w2w.C0:lerp(wing2offset*angles(0,0,math.rad(120+3600*math.cos(sine/800)))*cf(0,-5,1)*angles(0,0,math.rad(60)),lerp)
			w3w.C0 = w3w.C0:lerp(wing3offset*angles(0,0,math.rad(240+3600*math.cos(sine/800)))*cf(0,-5,1)*angles(0,0,math.rad(60)),lerp)
			w4w.C0 = w4w.C0:lerp(wing4offset*angles(0,0,math.rad(60))*cf(0,-3,2),lerp)
			w5w.C0 = w5w.C0:lerp(wing5offset*angles(0,0,math.rad(60+120))*cf(0,-3,2),lerp)
			w6w.C0 = w6w.C0:lerp(wing6offset*angles(0,0,math.rad(60+240))*cf(0,-3,2),lerp)
			height = 5+1*math.cos(sine/40)
			coredistance = 2.5
		elseif wingstyle.Value == "NIHIL" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(angles(0,0,math.rad(3600*math.cos(sine/1000)))*cf(0,-10,1)*wing1offset*angles(0,0,math.rad(3600*math.cos(sine/400)))*cf(0,-1,0),lerp)
			w2w.C0 = w2w.C0:lerp(angles(0,0,math.rad(3600*math.cos(sine/1000)))*cf(0,-10,1)*wing2offset*angles(0,0,math.rad(120+3600*math.cos(sine/400)))*cf(0,-1,0),lerp)
			w3w.C0 = w3w.C0:lerp(angles(0,0,math.rad(3600*math.cos(sine/1000)))*cf(0,-10,1)*wing3offset*angles(0,0,math.rad(240+3600*math.cos(sine/400)))*cf(0,-1,0),lerp)
			w4w.C0 = w4w.C0:lerp(angles(0,0,math.rad(3600*math.cos(sine/1000)))*cf(0,10,1)*wing4offset*angles(0,0,math.rad(3600*math.cos(sine/400)))*cf(0,-1,0),lerp)
			w5w.C0 = w5w.C0:lerp(angles(0,0,math.rad(3600*math.cos(sine/1000)))*cf(0,10,1)*wing5offset*angles(0,0,math.rad(120+3600*math.cos(sine/400)))*cf(0,-1,0),lerp)
			w6w.C0 = w6w.C0:lerp(angles(0,0,math.rad(3600*math.cos(sine/1000)))*cf(0,10,1)*wing6offset*angles(0,0,math.rad(240+3600*math.cos(sine/400)))*cf(0,-1,0),lerp)
			height = 8+1*math.cos(sine/40)
			coredistance = 2
		elseif wingstyle.Value == "TEMPEST" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(wing1offset*angles(0,0,math.rad(0+3600*math.cos(sine/300)))*cf(0,-3,1),lerp)
			w2w.C0 = w2w.C0:lerp(wing2offset*angles(0,0,math.rad(40+3600*math.cos(sine/300)))*cf(0,-3,1),lerp)
			w3w.C0 = w3w.C0:lerp(wing3offset*angles(0,0,math.rad(-40+3600*math.cos(sine/300)))*cf(0,-3,1),lerp)
			w4w.C0 = w4w.C0:lerp(wing4offset*angles(0,0,math.rad(180+3600*math.cos(sine/300)))*cf(0,-3,1),lerp)
			w5w.C0 = w5w.C0:lerp(wing5offset*angles(0,0,math.rad(220+3600*math.cos(sine/300)))*cf(0,-3,1),lerp)
			w6w.C0 = w6w.C0:lerp(wing6offset*angles(0,0,math.rad(140+3600*math.cos(sine/300)))*cf(0,-3,1),lerp)
			height = 5+.5*math.cos(sine/40)
			coredistance = 1.5
		elseif wingstyle.Value == "INFERNUM" then
			vpower = 1
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(wing1offset*cf(2.5,0+.25*math.cos(sine/30),1)*angles(0,0,math.rad(90+10*math.cos(sine/30))),lerp)
			w2w.C0 = w2w.C0:lerp(wing2offset*cf(14,13,1)*angles(0,0,math.rad(-90))*angles(0,0,math.rad(45)),lerp)
			w3w.C0 = w3w.C0:lerp(wing3offset*cf(1.5,2.25-.25*math.cos(sine/30),1)*angles(0,0,math.rad(45+120-10*math.cos(sine/30))),lerp)
			w4w.C0 = w4w.C0:lerp(wing4offset*cf(-2.5,-0+.25*math.cos(sine/30),1)*angles(0,0,math.rad(-90-10*math.cos(sine/30))),lerp)
			w5w.C0 = w5w.C0:lerp(wing5offset*cf(-14,13,1)*angles(0,0,math.rad(90))*angles(0,0,math.rad(-45)),lerp)
			w6w.C0 = w6w.C0:lerp(wing6offset*cf(-1.5,2.25-.25*math.cos(sine/30),1)*angles(0,0,math.rad(-45-120+10*math.cos(sine/30))),lerp)
			height = 0
			coredistance = 1.5
		elseif wingstyle.Value == "VIRTUE" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(wing1offset*cf(0,0,1)*angles(0,0,math.rad(0+3600*math.cos(sine/800)))*cf(0,-2,0),lerp)
			w2w.C0 = w2w.C0:lerp(wing2offset*cf(0,0,1)*angles(0,0,math.rad(90+3600*math.cos(sine/800)))*cf(0,-2,0),lerp)
			w3w.C0 = w3w.C0:lerp(wing3offset*cf(0,0,1)*angles(0,0,math.rad(180+3600*math.cos(sine/800)))*cf(0,-2,0),lerp)
			w4w.C0 = w4w.C0:lerp(wing4offset*cf(0,0,1)*angles(0,0,math.rad(270+3600*math.cos(sine/800)))*cf(0,-2,0),lerp)
			w5w.C0 = w5w.C0:lerp(wing5offset*cf(0,0,2)*angles(0,0,math.rad(-1800*math.cos(sine/800)))*cf(0,-2,0),lerp)
			w6w.C0 = w6w.C0:lerp(wing6offset*cf(0,0,2)*angles(0,0,math.rad(180-1800*math.cos(sine/800)))*cf(0,-2,0),lerp)
			height = 0
			coredistance = 2
		elseif wingstyle.Value == "DISSONANCE" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(wing1offset*cf(0,0,1)*angles(0,0,math.rad(45)),lerp)
			w2w.C0 = w2w.C0:lerp(wing2offset*cf(0,0,1)*angles(0,0,math.rad(45+180)),lerp)
			w3w.C0 = w3w.C0:lerp(wing3offset*cf(0,0,1)*angles(0,0,math.rad(-45)),lerp)
			w4w.C0 = w4w.C0:lerp(wing4offset*cf(0,0,1)*angles(0,0,math.rad(-45+180)),lerp)
			w5w.C0 = w5w.C0:lerp(wing5offset*cf(0,0,2)*angles(0,0,math.rad(90+45*math.cos(sine/100))),lerp)
			w6w.C0 = w6w.C0:lerp(wing6offset*cf(0,0,2)*angles(0,0,math.rad(90+180+45*math.cos(sine/100))),lerp)
			height = 4+1*math.cos(sine/60)
			coredistance = 1.5
		elseif wingstyle.Value == "ABSOLUTION" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(cf(0,0,2)*wing1offset*angles(0,0,math.rad(sine+3600*cs(600)))*cf(0,-2+.5*cs(40),0),lerp)
			w2w.C0 = w2w.C0:lerp(cf(0,0,2)*wing2offset*angles(0,0,math.rad(sine+120+3600*cs(600)))*cf(0,-2+.5*cs(40),0),lerp)
			w3w.C0 = w3w.C0:lerp(cf(0,0,2)*wing3offset*angles(0,0,math.rad(sine+240+3600*cs(600)))*cf(0,-2+.5*cs(40),0),lerp)
			w4w.C0 = w4w.C0:lerp(cf(0,0,2)*wing4offset*angles(0,0,math.rad(sine-3600*cs(600)))*cf(0,-2+.5*cs(40),0),lerp)
			w5w.C0 = w5w.C0:lerp(cf(0,0,2)*wing5offset*angles(0,0,math.rad(sine+120-3600*cs(600)))*cf(0,-2+.5*cs(40),0),lerp)
			w6w.C0 = w6w.C0:lerp(cf(0,0,2)*wing6offset*angles(0,0,math.rad(sine+240-3600*cs(600)))*cf(0,-2+.5*cs(40),0),lerp)
			height = 8+1*cs(45)
			coredistance = 2.5
		elseif wingstyle.Value == "WARPSPEED" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(cf(0,0,1.5)*wing1offset*angles(0,0,math.rad(90+22.5+22.5*cs(30)))*cf(0,-2+.5*cs(40),0),lerp)
			w2w.C0 = w2w.C0:lerp(cf(0,0,1.5)*wing2offset*angles(0,0,math.rad(90-22.5-22.5*cs(30)))*cf(0,-2+.5*cs(40),0),lerp)
			w3w.C0 = w3w.C0:lerp(cf(0,0,1.5)*wing3offset*angles(0,0,math.rad(-90+22.5+22.5*cs(30)))*cf(0,-2+.5*cs(40),0),lerp)
			w4w.C0 = w4w.C0:lerp(cf(0,0,1.5)*wing4offset*angles(0,0,math.rad(-90-22.5-22.5*cs(30)))*cf(0,-2+.5*cs(40),0),lerp)
			w5w.C0 = w5w.C0:lerp(cf(0,0,1.5)*wing5offset*angles(0,0,math.rad(0))*cf(0,1+1*cs(40),0),lerp)
			w6w.C0 = w6w.C0:lerp(cf(0,0,1.5)*wing6offset*angles(0,0,math.rad(180))*cf(0,1+1*cs(40),0),lerp)
			height = 0
			coredistance = 2
		elseif wingstyle.Value == "INTRICACY" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(cf(0,0,1.5)*wing1offset*angles(0,0,math.rad(90))*cf(0,-1+.5*cs(40),0),lerp)
			w2w.C0 = w2w.C0:lerp(cf(0,0,1.5)*wing2offset*angles(0,0,math.rad(-90))*cf(0,-1+.5*cs(40),0),lerp)
			w3w.C0 = w3w.C0:lerp(cf(0,0,1.5)*wing3offset*angles(0,0,math.rad(900*cs(600)))*cf(0,-1+.5*cs(40),0),lerp)
			w4w.C0 = w4w.C0:lerp(cf(0,0,1.5)*wing4offset*angles(0,0,math.rad(1800*cs(600)))*cf(0,-1+.5*cs(40),0),lerp)
			w5w.C0 = w5w.C0:lerp(cf(0,0,1.5)*wing5offset*angles(0,0,math.rad(2700*cs(600)))*cf(0,1+1*cs(40),0),lerp)
			w6w.C0 = w6w.C0:lerp(cf(0,0,1.5)*wing6offset*angles(0,0,math.rad(3600*cs(600)))*cf(0,1+1*cs(40),0),lerp)
			height = 3+1*cs(33)
			coredistance = 2
		elseif wingstyle.Value == "APOCALYPSE" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			w1w.C0 = w1w.C0:lerp(cf(0,0,1.5)*wing1offset*angles(0,0,math.rad(90+180*cs(200)))*cf(0,-2+.5*cs(40),0),lerp)
			w2w.C0 = w2w.C0:lerp(cf(0,0,1.5)*wing2offset*angles(0,0,math.rad(-90-180*cs(200)))*cf(0,-2+.5*cs(40),0),lerp)
			w3w.C0 = w3w.C0:lerp(cf(0,0,1.5)*wing3offset*angles(0,0,math.rad(-90-1800*cs(400)))*cf(0,-2+.5*cs(40),0),lerp)
			w4w.C0 = w4w.C0:lerp(cf(0,0,1.5)*wing4offset*angles(0,0,math.rad(-90+1800*cs(400)))*cf(0,-2+.5*cs(40),0),lerp)
			w5w.C0 = w5w.C0:lerp(cf(0,0,1.5)*wing5offset*angles(0,0,math.rad(90+1800*cs(400)))*cf(0,-1+1*cs(40),0),lerp)
			w6w.C0 = w6w.C0:lerp(cf(0,0,1.5)*wing6offset*angles(0,0,math.rad(90-1800*cs(400)))*cf(0,-1+1*cs(40),0),lerp)
			height = 4.5+1*cs(30)
			coredistance = 2
		elseif wingstyle.Value == "SAGITTARIUS" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			local x = 5
			local y = -10
			local z = 20
			w1w.C0 = w1w.C0:lerp(cf(0,0,2)*wing1offset*angles(0,0,math.rad(-3600*cs(600)+60))*cf(0,-y+z*cs(100)+x,0),lerp)
			w2w.C0 = w2w.C0:lerp(cf(0,0,2)*wing2offset*angles(0,0,math.rad(-3600*cs(600)+120))*cf(0,-y+z*cs(100)+x,0),lerp)
			w3w.C0 = w3w.C0:lerp(cf(0,0,2)*wing3offset*angles(0,0,math.rad(-3600*cs(600)+180))*cf(0,-y+z*cs(100)+x,0),lerp)
			w4w.C0 = w4w.C0:lerp(cf(0,0,2)*wing4offset*angles(0,0,math.rad(-3600*cs(600)+240))*cf(0,-y+z*cs(100)+x,0),lerp)
			w5w.C0 = w5w.C0:lerp(cf(0,0,2)*wing5offset*angles(0,0,math.rad(-3600*cs(600)+300))*cf(0,-y+z*cs(100)+x,0),lerp)
			w6w.C0 = w6w.C0:lerp(cf(0,0,2)*wing6offset*angles(0,0,math.rad(-3600*cs(600)+360))*cf(0,-y+z*cs(100)+x,0),lerp)
			w7w.C0 = w7w.C0:lerp(cf(0,0,4)*wing1offset*angles(0,0,math.rad(3600*cs(600)+60+30))*cf(0,-y-z*cs(100)+x,0),lerp)
			w8w.C0 = w8w.C0:lerp(cf(0,0,4)*wing2offset*angles(0,0,math.rad(3600*cs(600)+120+30))*cf(0,-y-z*cs(100)+x,0),lerp)
			w9w.C0 = w9w.C0:lerp(cf(0,0,4)*wing3offset*angles(0,0,math.rad(3600*cs(600)+180+30))*cf(0,-y-z*cs(100)+x,0),lerp)
			w10w.C0 = w10w.C0:lerp(cf(0,0,4)*wing4offset*angles(0,0,math.rad(3600*cs(600)+240+30))*cf(0,-y-z*cs(100)+x,0),lerp)
			w11w.C0 = w11w.C0:lerp(cf(0,0,4)*wing5offset*angles(0,0,math.rad(3600*cs(600)+300+30))*cf(0,-y-z*cs(100)+x,0),lerp)
			w12w.C0 = w12w.C0:lerp(cf(0,0,4)*wing6offset*angles(0,0,math.rad(3600*cs(600)+360+30))*cf(0,-y-z*cs(100)+x,0),lerp)
			height = 14+2*cs(50)
			coredistance = 5
		elseif wingstyle.Value == "HARMONY" then
			vpower = 0
			local lerp = .1
			w1o,w2o,w3o,w4o,w5o,w6o = 30,35,26,22,40,39
			ap = 5
			p = .3
			local x = 5
			local y = -10
			local z = 20
			w1w.C0 = w1w.C0:lerp(cf(0,0,2)*wing1offset*angles(0,0,math.rad(-3600*cs(600)))*cf(0,50,0)*angles(0,0,math.rad(3600*cs(500))),lerp)
			w2w.C0 = w2w.C0:lerp(cf(0,0,2)*wing1offset*angles(0,0,math.rad(-3600*cs(600)))*cf(0,50,0)*angles(0,0,math.rad(3600*cs(500)+180)),lerp)
			w3w.C0 = w3w.C0:lerp(cf(0,0,2)*wing2offset*angles(0,0,math.rad(120-3600*cs(600)))*cf(0,50,0)*angles(0,0,math.rad(3600*cs(500))),lerp)
			w4w.C0 = w4w.C0:lerp(cf(0,0,2)*wing2offset*angles(0,0,math.rad(120-3600*cs(600)))*cf(0,50,0)*angles(0,0,math.rad(3600*cs(500)+180)),lerp)
			w5w.C0 = w5w.C0:lerp(cf(0,0,2)*wing3offset*angles(0,0,math.rad(240-3600*cs(600)))*cf(0,50,0)*angles(0,0,math.rad(3600*cs(500))),lerp)
			w6w.C0 = w6w.C0:lerp(cf(0,0,2)*wing3offset*angles(0,0,math.rad(240-3600*cs(600)))*cf(0,50,0)*angles(0,0,math.rad(3600*cs(500)+180)),lerp)
			w7w.C0 = w7w.C0:lerp(cf(0,0,2)*wing4offset*angles(0,0,math.rad(3600*cs(600)+30*cs(100)))*cf(0,10,0),lerp)
			w8w.C0 = w8w.C0:lerp(cf(0,0,2)*wing4offset*angles(0,0,math.rad(3600*cs(600)+30*cs(100)+180))*cf(0,-10,0),lerp)
			w9w.C0 = w9w.C0:lerp(cf(0,0,2)*wing5offset*angles(0,0,math.rad(120+3600*cs(600)+30*cs(100)))*cf(0,10,0),lerp)
			w10w.C0 = w10w.C0:lerp(cf(0,0,2)*wing5offset*angles(0,0,math.rad(120+3600*cs(600)+30*cs(100)+180))*cf(0,-10,0),lerp)
			w11w.C0 = w11w.C0:lerp(cf(0,0,2)*wing6offset*angles(0,0,math.rad(240+3600*cs(600)+30*cs(100)))*cf(0,10,0),lerp)
			w12w.C0 = w12w.C0:lerp(cf(0,0,2)*wing6offset*angles(0,0,math.rad(240+3600*cs(600)+30*cs(100)+180))*cf(0,-10,0),lerp)
			height = 18+2*cs(50)
			coredistance = 2
		end
	end
	
	if Torso:FindFirstChild("Neck") then
		if anim.Value == "STARTUP" then
			g = .05
			RootJoint.C0 = RootJoint.C0:Lerp(RootCF*cf(0,0.3,0)*angles(math.rad(-5.9),math.rad(0),math.rad(-30.7)),g)
			Torso.Neck.C0 = Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(-6.5),math.rad(-6.1),math.rad(28.8)),g)
			LS.C0 = LS.C0:Lerp(cf(-1.4,0.9,-0.9)*angles(math.rad(160.4),math.rad(31),math.rad(-2.3)),g)
			RS.C0 = RS.C0:Lerp(cf(1.5,0.6,0.2)*angles(math.rad(2.1),math.rad(-15.2),math.rad(18.6)),g)
			LH.C0 = LH.C0:Lerp(cf(-0.9,-1,0)*angles(math.rad(-8.7),math.rad(20.1),math.rad(-7.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),g)
			RH.C0 = RH.C0:Lerp(cf(0.9,-0.9,0.1)*angles(math.rad(-5.6),math.rad(-24.4),math.rad(12.2))*angles(math.rad(0),math.rad(90),math.rad(0)),g)
		end
		if RootPart.Velocity.y > 1 and hitfloor==nil and root.Anchored==false then
			Anim="Jump"
			local lerp = .3
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,0,height)*angles(math.rad(-4.5),math.rad(0),math.rad(0)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(18.3),math.rad(0),math.rad(0)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.7,0.6,0)*angles(math.rad(24.5),math.rad(0),math.rad(-18.3)),lerp)
			RS.C0=RS.C0:Lerp(cf(1.6,0.5,-0.1)*angles(math.rad(24.5),math.rad(0),math.rad(19.3)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.9,-1,-0.1)*angles(math.rad(-10.8),math.rad(14.5),math.rad(-2.6))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.9,-0.1,-0.8)*angles(math.rad(-36.8),math.rad(-31.4),math.rad(6.3))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif RootPart.Velocity.y < -1 and hitfloor==nil and root.Anchored==false then 
			Anim="Fall"
			local Alpha = .3
			RootJoint.C0 = RootJoint.C0:lerp(cf(0,height,0)*angles(math.rad(-5),math.rad(0),math.rad(0))*RootCF,Alpha)
			LH.C0 = LH.C0:lerp(cf(-1,-1,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(15)),Alpha)
			RH.C0 = RH.C0:lerp(cf(1,-1,-0.3)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(85),math.rad(0)),Alpha)
			LS.C0 = LS.C0:lerp(cf(-1.5,0.5,0)*angles(math.rad(-5),math.rad(0),math.rad(-35)),Alpha)
			RS.C0 = RS.C0:lerp(cf(1.5,0.5,0)*angles(math.rad(-5),math.rad(0),math.rad(35)),Alpha)
			Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,.4)*angles(math.rad(-15),math.rad(0),math.rad(0))*necko,Alpha)
		end
		if torvel>15 and torvel <= 25 and hitfloor~=nil and height == 0 and root.Anchored==false then
			Anim="Walk"
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,-0.05,-0.05-0.05*math.cos(sine/5)+.1*math.sin(sine/5))*angles(math.rad(8*Vec.Z+5*math.cos(sine/5)),math.rad(-8*Vec.X),math.rad(8*math.cos(sine/10))),.1)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*angles(math.rad(-5*Vec.Z-3*math.cos(sine / 5)+3*math.sin(sine / 5)),math.rad(5*Vec.X),math.rad(-7*math.cos(sine/10))),.1)
			RS.C0=RS.C0:Lerp(cf(1.5,0.5+.1*math.cos(sine/5),.6*math.cos(sine/10)*Vec.Z)*angles(math.rad(-50*math.cos(sine / 10)*Vec.Z),0,math.rad(2.5+2.5*math.sin(sine/-5)-8*math.cos(sine/10)*Vec.X)),.1)
			LS.C0=LS.C0:Lerp(cf(-1.5,0.5+.1*math.cos(sine/5),-.6*math.cos(sine/10)*Vec.Z)*angles(math.rad(50*math.cos(sine / 10)*Vec.Z),0,math.rad(-2.5-2.5*math.sin(sine/-5)+8*math.cos(sine/10)*Vec.X)),.1)
			RH.C0=RH.C0:Lerp(cf(1,-1+.2*math.sin(sine/-10),0-.25*math.cos(sine/10)*Vec.Z-0.2*math.cos(sine/10)*Vec.X)*angles(0,math.rad(90),0)*angles(math.rad(-20*math.cos(sine/10)*Vec.X),math.rad(-8*math.cos(sine/10)),math.rad(35*math.cos(sine / 10)*Vec.Z)),.1)
			LH.C0=LH.C0:Lerp(cf(-1,-1+.2*math.sin(sine/10),0+.25*math.cos(sine/10)*Vec.Z-0.2*math.cos(sine/10)*Vec.X)*angles(0,math.rad(-90),0)*angles(math.rad(-20*math.cos(sine/10)*Vec.X),math.rad(-8*math.cos(sine/10)),math.rad(35*math.cos(sine / 10)*Vec.Z)),.1)
		end
		if torvel>1 and torvel <= 15 and hitfloor~=nil and height == 0 and root.Anchored==false then
			Anim="Walk"
			local m = 14
			local n = m/2
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,-0.05,-0.05-0.05*math.cos(sine/n)+.1*math.sin(sine/n))*angles(math.rad(8*Vec.Z+2*math.cos(sine/n)),math.rad(-8*Vec.X),math.rad(8*math.cos(sine/m))),.1)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*angles(math.rad(10-5*Vec.Z+3*math.sin(sine / n)),math.rad(5*Vec.X),math.rad(-7*math.cos(sine/m))),.1)
			RS.C0=RS.C0:Lerp(cf(1.5,0.5+.1*math.cos(sine/n),.3*math.cos(sine/m)*Vec.Z)*angles(math.rad(-40*math.cos(sine / m)*Vec.Z),0,math.rad(2.5+2.5*math.sin(sine/-n)-8*math.cos(sine/m)*Vec.X)),.1)
			LS.C0=LS.C0:Lerp(cf(-1.5,0.5+.1*math.cos(sine/n),-.3*math.cos(sine/m)*Vec.Z)*angles(math.rad(40*math.cos(sine / m)*Vec.Z),0,math.rad(-2.5-2.5*math.sin(sine/-n)+8*math.cos(sine/m)*Vec.X)),.1)
			RH.C0=RH.C0:Lerp(cf(1,-1+.15*math.sin(sine/-m),0-.05*math.cos(sine/m)*Vec.Z-0.2*math.cos(sine/m)*Vec.X)*angles(0,math.rad(90),0)*angles(math.rad(-20*math.cos(sine/m)*Vec.X),math.rad(-8*math.cos(sine/m)),math.rad(25*math.cos(sine / m)*Vec.Z)),.1)
			LH.C0=LH.C0:Lerp(cf(-1,-1+.15*math.sin(sine/m),0+.05*math.cos(sine/m)*Vec.Z-0.2*math.cos(sine/m)*Vec.X)*angles(0,math.rad(-90),0)*angles(math.rad(-20*math.cos(sine/m)*Vec.X),math.rad(-8*math.cos(sine/m)),math.rad(25*math.cos(sine / m)*Vec.Z)),.1)
		end
		if torvel>25 and hitfloor~=nil and height == 0 and root.Anchored==false then
			Anim="Walk"
			local lerp = .3
			local m = 6
			local n = m/2
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,-0.05,-0.05-0.05*math.cos(sine/n)+.05*math.sin(sine/n))*angles(math.rad(10+20*Vec.Z+3*math.cos(sine/n)),math.rad(-14*Vec.X),math.rad(4*math.cos(sine/m))),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*angles(math.rad(-20*Vec.Z-7*math.cos(sine / n)),math.rad(5*Vec.X),math.rad(-3*math.cos(sine/m))),lerp)
			RS.C0=RS.C0:Lerp(cf(1.5,0.5+.2*math.cos(sine/n),.8*math.cos(sine/m)*Vec.Z)*angles(math.rad(10-75*math.cos(sine /m)*Vec.Z),0,math.rad(5-8*math.cos(sine/m)*Vec.X)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.5,0.5+.2*math.cos(sine/n),-.8*math.cos(sine/m)*Vec.Z)*angles(math.rad(10+75*math.cos(sine /m)*Vec.Z),0,math.rad(-5+8*math.cos(sine/m)*Vec.X)),lerp)
			RH.C0=RH.C0:Lerp(cf(1,-.8+.5*math.sin(sine/-m),0-.25*math.cos(sine/m)*Vec.Z-0.2*math.cos(sine/m)*Vec.X)*angles(0,math.rad(90),0)*angles(math.rad(-20*math.cos(sine/m)*Vec.X),math.rad(-8*math.cos(sine/m)),math.rad(10+65*math.cos(sine / m)*Vec.Z)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1,-.8+.5*math.sin(sine/m),0+.25*math.cos(sine/m)*Vec.Z-0.2*math.cos(sine/m)*Vec.X)*angles(0,math.rad(-90),0)*angles(math.rad(-20*math.cos(sine/m)*Vec.X),math.rad(-8*math.cos(sine/m)),math.rad(10+65*math.cos(sine / m)*Vec.Z)),lerp)
		end
		if height > 0 and torvel>1 and hitfloor~=nil and root.Anchored==false then
			Anim="Walk"
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,0,height)*angles(math.rad(0 + 55*Vec.Z + 5 * math.cos(sine / 20)),math.rad(0 - 25*Vec.X),math.rad(0 * math.cos(sine / 10))),.1)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*angles(math.rad(0 - 40*Vec.Z + 5  * math.cos(sine / 20)),math.rad(0 + 0 * math.cos(sine / 5)),math.rad(0 - 0 * math.cos(sine / 10))),.1)
			RS.C0=RS.C0:Lerp(cf(1.5,0.5,0)*angles(math.rad(-10+2*math.cos(sine/22)),math.rad(-15+2*math.cos(sine/26)),math.rad(15+2*math.cos(sine/26))),.1)
			LS.C0=LS.C0:Lerp(cf(-1.5,0.5,0)*angles(math.rad(-10+2*math.cos(sine/24)),math.rad(15+2*math.cos(sine/24)),math.rad(-15+2*math.cos(sine/22))),.1)
			RH.C0=RH.C0:Lerp(cf(1,-0.3,-0.5)*angles(0,math.rad(90),0)*angles(0,0,math.rad(-15+2*math.cos(sine/20))),.1)
			LH.C0=LH.C0:Lerp(cf(-1,-1,0)*angles(0,math.rad(-90),0)*angles(0,0,math.rad(10+2*math.cos(sine/24))),.1)
		end
		if torvel<1 and hitfloor~=nil then
			if anim.Value == "APEX" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				local h = 30
				local g = h*2
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(.2*math.sin(sine/g),0,0+.1*math.cos(sine/h))*angles(math.rad(-9.6),math.rad(-4.7+5*math.sin(sine/g)),math.rad(29.2)),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*furyshake()*cf(0,0,0)*angles(math.rad(16.1+6*math.cos(sine/25)),math.rad(0+3*math.cos(sine/28)),math.rad(-24.3+3*math.cos(sine/h))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.6,0.6-.07*math.sin(sine/h),0)*furyshake()*angles(math.rad(-9.5),math.rad(0),math.rad(-20.2-10*math.sin(sine/h))),lerp)
				RS.C0=RS.C0:Lerp(cf(1.6,0.6-.07*math.sin(sine/h),0)*furyshake()*angles(math.rad(0),math.rad(0),math.rad(22.7+10*math.sin(sine/h))),lerp)
				LH.C0=LH.C0:Lerp(cf(-1.1+.1*math.sin(sine/g),-.8-.1*math.cos(sine/h)+.05*math.sin(sine/g)-leftlegheight,0.1)*angles(math.rad(-26.6),math.rad(23.2),math.rad(-9.5-5*math.sin(sine/g)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.9+.1*math.sin(sine/g),-1-.1*math.cos(sine/h)-.05*math.sin(sine/g)-rightlegheight,-0.3)*angles(math.rad(-1.8),math.rad(-20.1),math.rad(17.4-5*math.sin(sine/g)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "DOWNFALL" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				local h = 30
				local g = h*2
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(.2*math.sin(sine/g),0,0+.1*math.cos(sine/h))*angles(math.rad(-9.6),math.rad(-4.7+5*math.sin(sine/g)),math.rad(29.2)),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*furyshake()*cf(0,0,0)*angles(math.rad(30+6*math.cos(sine/25)),math.rad(0+3*math.cos(sine/28)),math.rad(-24.3+3*math.cos(sine/h))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.6,0.3-.07*math.sin(sine/h),0)*furyshake()*angles(math.rad(-15),math.rad(30),math.rad(40)),lerp)
				RS.C0=RS.C0:Lerp(cf(1.6,0.3-.07*math.sin(sine/h),0)*furyshake()*angles(math.rad(-15),math.rad(-30),math.rad(-40)),lerp)
				LH.C0=LH.C0:Lerp(cf(-1.1+.1*math.sin(sine/g),-.8-.1*math.cos(sine/h)+.05*math.sin(sine/g)-leftlegheight,0.1)*angles(math.rad(-26.6),math.rad(23.2),math.rad(-9.5-5*math.sin(sine/g)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.9+.1*math.sin(sine/g),-1-.1*math.cos(sine/h)-.05*math.sin(sine/g)-rightlegheight,-0.3)*angles(math.rad(-1.8),math.rad(-20.1),math.rad(17.4-5*math.sin(sine/g)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "EXASPERATION" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0 = RootJoint.C0:lerp(cf(0,0 - .15 * math.sin(sine/40),0)*angles(math.rad(12.3),math.rad(44.3),math.rad(-8.6))*RootCF,lerp)
				Torso.Neck.C0 = Torso.Neck.C0:lerp(necko*furyshake()*angles(math.rad(17.9 +5 * math.cos(sine/40) + math.random(-2,2)),math.rad(-6.4+ math.random(-2,2)),math.rad(-38.5+ math.random(-2,2))),.2)
				LS.C0 = LS.C0:lerp(cf(-1.5,0.3+.1 * math.cos(sine/40),0.2)*furyshake()*angles(math.rad(8.3),math.rad(25.8),math.rad(-22)),lerp)
				RS.C0 = RS.C0:lerp(cf(1.5,0.2+.1 * math.cos(sine/40),0.4)*furyshake()*angles(math.rad(-5.8),math.rad(-32.8),math.rad(18.9)),lerp)
				LH.C0 = LH.C0:lerp(cf(-1,-1+.15 * math.sin(sine/40),0)*angles(math.rad(-11.4),math.rad(8.9),math.rad(-9.6))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0 = RH.C0:lerp(cf(1,-1+.15 * math.sin(sine/40),0)*angles(math.rad(-15.6),math.rad(-33.9),math.rad(6.3))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "PERDURANCE" then
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(1*cs(80),1*cs(100),height)*angles(math.rad(-1.2+5*cs(45)),math.rad(42.5+5*cs(65)),math.rad(-46.3+5*cs(51))),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(40.9+3*cs(47)),math.rad(-30.3+5*cs(43)),math.rad(58.8+3*cs(41))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.2,0.3+.1*math.sin(57),-0.6)*furyshake()*angles(math.rad(109.1+10*math.sin(sine/57)),math.rad(23.2+10*math.sin(sine/57)),math.rad(24.9)),lerp)
				RS.C0=RS.C0:Lerp(cf(1.6,0.3+.1*math.sin(57),0)*furyshake()*angles(math.rad(-4.6),math.rad(14.9),math.rad(71.9+20*math.sin(sine/57))),lerp)
				LH.C0=LH.C0:Lerp(cf(-1,-0.9,0.1)*angles(math.rad(-8.3+5*cs(50)),math.rad(10.4+5*cs(62)),math.rad(-7+5*cs(64)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.9,-0.3+.2*cs(47),-0.8)*angles(math.rad(-12.1+10*cs(50)),math.rad(-9.6+5*cs(44)),math.rad(5+5*cs(49)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "REPRESSION" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(.2*math.cos(sine/40),0,-0.2+.1*math.cos(sine/30))*angles(math.rad(19.2),math.rad(0+5*math.cos(sine/40)),math.rad(-30.1)),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(-18.3+6*math.cos(sine/25)),math.rad(1.2+3*math.cos(sine/28)),math.rad(27.8+3*math.cos(sine/32))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.5,0.7+.1*math.cos(sine/34),0)*furyshake()*angles(math.rad(0),math.rad(0),math.rad(-90-10*math.cos(sine/35))),lerp)
				RS.C0=RS.C0:Lerp(cf(1.5,0.7+.1*math.cos(sine/34),0)*furyshake()*angles(math.rad(0),math.rad(0),math.rad(90+10*math.cos(sine/35))),lerp)
				LH.C0=LH.C0:Lerp(cf(-1.1,-0.8+.1*math.cos(sine/40)-.1*math.cos(sine/30)-leftlegheight,0)*angles(math.rad(26.2),math.rad(37.7),math.rad(-19.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.8,-1.2-.1*math.cos(sine/40)-.1*math.cos(sine/30)-rightlegheight,0.1)*angles(math.rad(0),math.rad(-25.5),math.rad(12))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "ADMISSION" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(.2*math.cos(sine/40),0,-0.2+.1*math.cos(sine/30))*angles(math.rad(19.2),math.rad(0+5*math.cos(sine/40)),math.rad(-30.1)),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(6*math.cos(sine/25)),math.rad(1.2+3*math.cos(sine/28)),math.rad(-5+3*math.cos(sine/32))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.1,0.1-.07*math.sin(sine/30),.4)*furyshake()*angles(math.rad(15),math.rad(-30),math.rad(40)),lerp)
				RS.C0=RS.C0:Lerp(cf(1.1,0.1-.07*math.sin(sine/30),.4)*furyshake()*angles(math.rad(15),math.rad(30),math.rad(-40)),lerp)
				LH.C0=LH.C0:Lerp(cf(-1.1,-0.8+.1*math.cos(sine/40)-.1*math.cos(sine/30)-leftlegheight,0)*angles(math.rad(26.2),math.rad(37.7),math.rad(-19.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.8,-1.2-.1*math.cos(sine/40)-.1*math.cos(sine/30)-rightlegheight,0.1)*angles(math.rad(0),math.rad(-25.5),math.rad(12))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "EXECUTION" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(1*cs(70),1*cs(80),5-1*math.cos(sine/50))*angles(math.rad(-10+5*math.cos(sine/35)),math.rad(-30+5*math.cos(sine/37)),math.rad(67.6+5*math.cos(sine/42))),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(30+5*math.cos(sine/36)),math.rad(-10+5*math.cos(sine/33)),math.rad(-67.6+5*math.cos(sine/39))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.5,-0.3+.2*math.cos(sine/35),-0.2)*furyshake()*angles(math.rad(113.9+8*math.cos(sine/41)),math.rad(25.4+5*math.cos(sine/39)),math.rad(0+5*math.cos(sine/37))),lerp)
				RS.C0=RS.C0:Lerp(cf(1.5,0.4,-0.1)*furyshake()*angles(math.rad(1.3+5*math.cos(sine/36)),math.rad(16.4+5*math.cos(sine/38)),math.rad(81.6+5*math.cos(sine/33))),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.9,-1,-0.1)*angles(math.rad(-64.9+20*math.cos(sine/38)),math.rad(12+5*math.cos(sine/44)),math.rad(-6.9+5*math.cos(sine/36)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(1,0+.25*math.cos(sine/43),-0.7)*angles(math.rad(-19+5*math.cos(sine/30)),math.rad(-16.2+5*math.cos(sine/38)),math.rad(7.5+5*math.cos(sine/45)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "STIGMA" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(1*cs(70),1*cs(80),5-1*math.cos(sine/50))*angles(math.rad(-10+5*math.cos(sine/35)),math.rad(-30+5*math.cos(sine/37)),math.rad(67.6+5*math.cos(sine/42))),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(30+5*math.cos(sine/36)),math.rad(-10+5*math.cos(sine/33)),math.rad(-67.6+5*math.cos(sine/39))),lerp)
				RS.C0=RS.C0:Lerp(cf(1.2,-0.4-.15*math.sin(sine/50),-0.3)*furyshake()*angles(math.rad(119.3-20*math.sin(sine/50)),math.rad(66.3),math.rad(-0.5)),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.1,0.6+.15*math.sin(sine/50),-0.6)*furyshake()*angles(math.rad(131.8),math.rad(26.6),math.rad(37)),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.8,-1-.1*math.sin(sine/50),-0.3)*angles(math.rad(-29.5+10*math.cos(sine/50)),math.rad(5.8+5*math.cos(sine/30)),math.rad(-12.6+5*math.cos(sine/48)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(1,0+.25*math.cos(sine/43),-0.7)*angles(math.rad(-19+5*math.cos(sine/30)),math.rad(-16.2+5*math.cos(sine/38)),math.rad(7.5+5*math.cos(sine/45)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "VINDICTIVE" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(1*cs(75),1*cs(80),5+1*math.cos(sine/60))*angles(math.rad(-15.9+7*cs(50)),math.rad(-4.5+5*cs(47)),math.rad(23.8+5*cs(52))),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(20.8+5*cs(46)),math.rad(5.1+3*cs(55)),math.rad(-23.8+3*cs(47))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.7,0.8,-0.1)*furyshake()*angles(math.rad(-3.4+5*cs(44)),math.rad(-5.5+5*cs(57)),math.rad(-42.2+20*cs(47))),lerp)
				RS.C0=RS.C0:Lerp(cf(1.2,0.8+.2*cs(57),-0.5)*furyshake()*angles(math.rad(170.6),math.rad(3),math.rad(-19.1)),lerp)
				LH.C0=LH.C0:Lerp(cf(-1,-1,0)*angles(math.rad(0+5*cs(47)),math.rad(0+5*cs(39)),math.rad(10*cs(55)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(1,-0.2+.4*cs(58),-1)*angles(math.rad(-30.4+5*cs(48)),math.rad(-11.9+5*cs(52)),math.rad(4.8+5*cs(58)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "NIHIL" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(1*cs(70),1*cs(60),8+1*math.cos(sine/50))*angles(math.rad(-8.3+5*math.cos(sine/37)),math.rad(0+5*math.cos(sine/33)),math.rad(51.1+5*math.cos(sine/42))),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(-0,0,0)*furyshake()*angles(math.rad(14.5+5*math.cos(sine/25)),math.rad(-11.3+2*math.cos(sine/28)),math.rad(-45.8+2*math.cos(sine/24))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.1,0.5+.1*math.cos(sine/36),0.5)*furyshake()*angles(math.rad(-7.2),math.rad(-26.6),math.rad(40.4)),lerp)
				RS.C0=RS.C0:Lerp(cf(1,0.4+.1*math.cos(sine/36),0.8)*furyshake()*angles(math.rad(-14.8),math.rad(16.4),math.rad(-45.8)),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.8,-0.9,0)*angles(math.rad(-2.9+5*math.cos(sine/33)),math.rad(10.2+5*math.cos(sine/29)),math.rad(-9.7+5*math.cos(sine/40)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.8,-0.1+.2*math.cos(sine/39),-0.7)*angles(math.rad(-6.2+5*math.cos(sine/42)),math.rad(-13.9+5*math.cos(sine/41)),math.rad(8.9+5*math.cos(sine/37)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "ANARCHY" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(1*cs(80),1*cs(60),5+1*cs(30))*angles(math.rad(-35.3+7*cs(55)),math.rad(-20.1+7*cs(56)),math.rad(31.2+7*cs(48))),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(38.9+3+5*cs(53)),math.rad(-5+3*cs(48)),math.rad(-32.3+3*cs(61))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.3,0.2+.2*cs(47),-0.5)*furyshake()*angles(math.rad(63.9),math.rad(-18.1),math.rad(67.1)),lerp)
				RS.C0=RS.C0:Lerp(cf(1,0.5+.2*cs(47),0.8)*furyshake()*angles(math.rad(-53.1),math.rad(-13.8),math.rad(-63.6)),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.8,-0.8,-0.2)*angles(math.rad(-43.3+5*cs(56)),math.rad(13.6+5*cs(58)),math.rad(-14.6+5*cs(53)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(1.1,-0.7+.4*cs(45),-1.3)*angles(math.rad(-55.1+5*cs(48)),math.rad(-21.2+5*cs(55)),math.rad(9.4+5*cs(52)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "TEMPEST" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(1*cs(67),1*cs(57),5+.5*math.cos(sine/40))*angles(math.rad(0+5*math.cos(sine/36)),math.rad(0+5*math.cos(sine/60)),math.rad(-46.2+5*math.cos(sine/45))),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(9.8+5*math.cos(sine/37)),math.rad(-11.4+3*math.cos(sine/39)),math.rad(46.6+3*math.cos(sine/42))),lerp)
				LS.C0=LS.C0:Lerp(cf(-0.5,0.5+.1*math.cos(sine/42),-0.6)*furyshake()*angles(math.rad(96.3),math.rad(-9.8),math.rad(76.2)),lerp)
				RS.C0=RS.C0:Lerp(cf(1.1,0.6+.1*math.cos(sine/42),-0.5)*furyshake()*angles(math.rad(-158),math.rad(-9.9),math.rad(-28.1)),lerp)
				LH.C0=LH.C0:Lerp(cf(-1,-1,0)*angles(math.rad(5*math.cos(sine/38)),math.rad(5*math.cos(sine/44)),math.rad(5*math.cos(sine/37)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(1,-0.2+.3*math.cos(sine/38),-0.9)*angles(math.rad(-25.8+5*math.cos(sine/37)),math.rad(5*math.cos(sine/46)),math.rad(5*math.cos(sine/49)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "INFERNUM" then
				Anim="Idle"
				local lerp = .05
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(-0.1+.1*cs(50),.6,-0.7+.15*cs(45))*angles(0,math.rad(5*cs(50)),0)*angles(math.rad(-25),math.rad(10.4),math.rad(-23.1)),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(30.8+5*cs(46)),math.rad(-14.4+3*cs(43)),math.rad(19+5*cs(50)+3*cs(47))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.5,0.3+.2*cs(43),0.2)*furyshake()*angles(math.rad(20*cs(48)-24.1+5*cs(44)),math.rad(0+5*cs(48)),math.rad(0)),lerp)
				RS.C0=RS.C0:Lerp(cf(1.5,0.3+.2*cs(43),0.2)*furyshake()*angles(math.rad(20*cs(48)-24.1+5*cs(42)),math.rad(0+5*cs(52)),math.rad(0)),lerp)
				LH.C0=LH.C0:Lerp(cf(-1+.1*cs(50),-0.8-.15*cs(45)-leftlegheight,-0.7)*angles(math.rad(-11.4),math.rad(26.7),math.rad(-13.5-5*cs(50)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.7+.1*cs(50),-1.1-.15*cs(45)-rightlegheight,-0.6)*angles(math.rad(-58.6),math.rad(-16.9),math.rad(11-5*cs(50)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "VIRTUE" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0.1*math.sin(sine/50),0,0+.1*cs(25))*angles(0,math.rad(5*math.sin(sine/50)),0)*angles(math.rad(0),math.rad(0),math.rad(-56.9)),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(0),math.rad(-9+5*cs(50)),math.rad(54.6)),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.7,0.4+.2*cs(28),0)*furyshake()*angles(math.rad(0),math.rad(0),math.rad(-32.7-15*math.sin(sine/28))),lerp)
				RS.C0=RS.C0:Lerp(cf(0.6,-0.1,-0.7)*furyshake()*angles(math.rad(174.2+5*cs(50)),math.rad(-3),math.rad(-19.7-5*cs(50))),lerp)
				LH.C0=LH.C0:Lerp(cf(-1-0.1*math.sin(sine/50),-1+.05*math.sin(sine/50)-.1*cs(25)-leftlegheight,0.3)*angles(math.rad(8.8+5*math.sin(sine/50)),math.rad(32.4),math.rad(-11.8-5*math.sin(sine/50)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(1-0.05*math.sin(sine/50),-1-.05*math.sin(sine/50)-.1*cs(25)-rightlegheight,-0.2)*angles(math.rad(-17.7-5*math.sin(sine/50)),math.rad(-15.7),math.rad(12.3))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "ABSOLUTION" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(1*cs(65),1*cs(70),height)*angles(0,math.rad(10*math.sin(sine/90)),0)*angles(math.rad(-12.2+5*cs(48)),math.rad(5*cs(50)),math.rad(-45.2+5*cs(40))),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(20.1),math.rad(17.6-10*math.sin(sine/90)),math.rad(37.1)),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.1,0.4+.2*cs(56),-0.3)*furyshake()*angles(math.rad(81.7+10*cs(50)),math.rad(13.8+3*cs(47)),math.rad(58.9+3*cs(40))),lerp)
				RS.C0=RS.C0:Lerp(cf(0.9,0.3+.2*cs(56),-0.8)*furyshake()*angles(math.rad(68.7+10*cs(50)),math.rad(7+3*cs(53)),math.rad(-71+3*cs(59))),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.9,-0.4+.2*cs(46),-1.1)*angles(math.rad(-54.9+10*cs(42)),math.rad(13.1),math.rad(-3.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.9,-1+.1*cs(49),-0.3)*angles(math.rad(-31.5),math.rad(-35.8),math.rad(0.6))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "RETENTION" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(1*cs(65),1*cs(70),height)*angles(0,math.rad(10*math.sin(sine/90)),0)*angles(math.rad(12.2+5*cs(48)),math.rad(5*cs(50)),math.rad(-45.2+5*cs(40))),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*furyshake()*angles(math.rad(30.1),math.rad(17.6-10*math.sin(sine/90)),math.rad(37.1)),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.4,1,-0.5)*angles(math.rad(122.9),math.rad(16.4),math.rad(54.8)),lerp)
				RS.C0=RS.C0:Lerp(cf(1.1,0.1-.07*math.sin(sine/30),.4)*furyshake()*angles(math.rad(15),math.rad(30),math.rad(-40)),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.9,-0.4+.2*cs(46),-1.1)*angles(math.rad(-54.9+10*cs(42)),math.rad(13.1),math.rad(-3.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.9,-1+.1*cs(49),-0.3)*angles(math.rad(-31.5),math.rad(-35.8),math.rad(0.6))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "DISSONANCE" then
				Anim="Idle"
				local lerp = .05
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(cf(2*cs(80),height,2*cs(130))*angles(math.rad(51.5+5*cs(70)),math.rad(0),math.rad(0))*RootCF,lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0,0.6,0.8)*furyshake()*angles(math.rad(-61.2-5*math.sin(sine/60)),math.rad(3*cs(50)),math.rad(3*cs(85)))*necko,lerp)
				RS.C0=RS.C0:Lerp(cf(1.5,0.7,0.3-.3*math.sin(sine/60))*furyshake()*angles(math.rad(-51.3),math.rad(0),math.rad(0)),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.5,0.7,0.3-.3*math.sin(sine/60))*furyshake()*angles(math.rad(-51.3),math.rad(0),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.9,0.1,-1)*angles(math.rad(-17.7-10*math.sin(sine/60)),math.rad(4.8),math.rad(7.8))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.8,-0.9,0)*angles(math.rad(-30.4),math.rad(13.8),math.rad(-8.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			elseif anim.Value == "WARPSPEED" then
				Anim = "Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(cf(0,-0.5+.1*cs(32),0)*angles(math.rad(-43.5+5*math.sin(sine/32)),math.rad(26.7),math.rad(0))*RootCF,lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0.3,0.3,-0.6)*furyshake()*angles(math.rad(37+5*math.sin(sine/32)),math.rad(-17.1+3*cs(43)),math.rad(19.9+3*cs(68)))*necko,lerp)
				RS.C0=RS.C0:Lerp(cf(1.3,0.7+.1*math.sin(sine/32),-0.9)*furyshake()*angles(math.rad(115.8-10*math.sin(sine/32)),math.rad(12),math.rad(-53.8)),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.6,0.1+.1*math.sin(sine/32),0.2)*furyshake()*angles(math.rad(7.1),math.rad(13.6),math.rad(-64.4-10*math.sin(sine/32))),lerp)
				RH.C0=RH.C0:Lerp(cf(1.2,0-.05*cs(32)-.05*math.sin(sine/32)-rightlegheight,-0.2-.05*cs(32)+.05*math.sin(sine/32))*angles(math.rad(50.1-5*math.sin(sine/32)),math.rad(-20.6),math.rad(22.8))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.8,-0.7-.05*cs(32)-.05*math.sin(sine/32)-leftlegheight,-0.6-.05*cs(32)+.05*math.sin(sine/32))*angles(math.rad(6.6-5*math.sin(sine/32)),math.rad(6.3),math.rad(-7.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			elseif anim.Value == "APOCALYPSE" then
				Anim = "Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(cf(1*cs(49),height,1*cs(80))*angles(math.rad(-29.7-10*math.sin(sine/30)),math.rad(-31.7+5*cs(60)),math.rad(5*cs(70)))*RootCF,lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(-0.1,0,-0.2)*furyshake()*angles(math.rad(20.4+10*math.sin(sine/30)),math.rad(33.4+7*cs(37)),math.rad(-11.6+7*cs(55)))*necko,lerp)
				RS.C0=RS.C0:Lerp(cf(1.6,-0.4+.2*math.sin(sine/30),-0.1)*furyshake()*angles(math.rad(-151+10*math.sin(sine/30)),math.rad(-46.1),math.rad(34.5-20*cs(30))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.6,-0.3+.2*math.sin(sine/30),-0.6)*furyshake()*angles(math.rad(178.7+10*math.sin(sine/30)),math.rad(24.9),math.rad(-16.9+20*cs(30))),lerp)
				RH.C0=RH.C0:Lerp(cf(0.9,0.2+.4*math.sin(sine/30),-1.1)*angles(math.rad(-14.7+10*math.sin(sine/30)),math.rad(-5.6+10*cs(70)),math.rad(10*cs(80)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.9,-1,0.2)*angles(math.rad(17.5+10*cs(60)),math.rad(14.4+10*cs(68)),math.rad(-7.8+10*cs(90)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			elseif anim.Value == "INTRICACY" then
				Anim = "idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(cf(1*cs(48),height,1*cs(57))*angles(math.rad(5*cs(25)),math.rad(64.5+5*cs(60)),math.rad(5*cs(39)))*RootCF,lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(-0.1,0,0)*furyshake()*angles(math.rad(-9+4*math.sin(sine/33)),math.rad(-64.2+5*cs(80)),math.rad(-8.1+5*cs(71)))*necko,lerp)
				RS.C0=RS.C0:Lerp(cf(1.1,0.6+.15*math.sin(sine/33),0.4)*furyshake()*angles(math.rad(10.6),math.rad(31.3),math.rad(-39.7)),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.2,1.1+.15*math.sin(sine/33),-0.3)*furyshake()*angles(math.rad(157.5),math.rad(9.5),math.rad(29.8)),lerp)
				RH.C0=RH.C0:Lerp(cf(1.2,-0.2+.3*math.sin(sine/33),-0.6)*angles(math.rad(2.4-10*math.sin(sine/33)),math.rad(-29.7),math.rad(6.6))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.9,-1,0.1)*angles(math.rad(5*cs(47)),math.rad(11.1+5*cs(53)),math.rad(-11.3+5*cs(30)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			elseif anim.Value == "SAGITTARIUS" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,0,14+2*cs(50))*angles(math.rad(-36.8),math.rad(42.4),math.rad(-41.9)),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*furyshake()*cf(0,0,0)*angles(math.rad(60),math.rad(-9.8),math.rad(45.6)),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.5,0.4,0.1)*furyshake()*angles(math.rad(-12.4),math.rad(-24.3),math.rad(23.4)),lerp)
				RS.C0=RS.C0:Lerp(cf(1.6,-0.2,-0.5)*furyshake()*angles(math.rad(119.1),math.rad(7),math.rad(-7.7)),lerp)
				LH.C0=LH.C0:Lerp(cf(-1,-1,-0.1)*angles(math.rad(-37.4),math.rad(28.4),math.rad(-18))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.4,-0.1,-1.2)*angles(math.rad(-36.2),math.rad(-26.5),math.rad(21.7))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			elseif anim.Value == "HARMONY" then
				Anim="Idle"
				local lerp = .07
				if fury.Value == true then lerp = .3 end
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,0,18+2*cs(50))*angles(math.rad(-25+5*cs(55)),math.rad(5*cs(58)),math.rad(5*cs(45))),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*furyshake()*cf(0,0,0)*angles(math.rad(-22.7+5*cs(54)),math.rad(5*cs(48)),math.rad(5*cs(51))),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.5,1,0)*furyshake()*angles(math.rad(-25.4),math.rad(0),math.rad(-90+10*math.sin(sine/-50))),lerp)
				RS.C0=RS.C0:Lerp(cf(1.5,1,0)*furyshake()*angles(math.rad(-25.4),math.rad(0),math.rad(90-10*math.sin(sine/-50))),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.9,-0.8,0.1)*angles(math.rad(-25.6+5*cs(59)),math.rad(14.5+5*cs(57)),math.rad(-2.6))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.7,-0.4+.3*cs(55),-1)*angles(math.rad(-44.9+10*cs(58)),math.rad(-15.2+5*cs(47)),math.rad(13.7+5*cs(44)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			end
		end
		
		if anim.Value == "SWITCH START" then
			local lerp = .4
			if height == 0 then
				RootJoint.C0=RootJoint.C0:Lerp(cf(0,0.1,-0.3)*angles(math.rad(-35.5),math.rad(0),math.rad(0))*RootCF,.1)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0,0.1,0.4)*angles(math.rad(-27.1),math.rad(math.random(-2,2)),math.rad(math.random(-2,2)))*necko,lerp)
				RS.C0=RS.C0:Lerp(cf(1.1,0.1,-0.5)*angles(math.rad(161.1+math.random(-2,2)),math.rad(-4.6+math.random(-2,2)),math.rad(-32.5+math.random(-2,2))),lerp)
				LS.C0=LS.C0:Lerp(cf(-0.9,0.3,-0.5)*angles(math.rad(166.3+math.random(-2,2)),math.rad(-6.3+math.random(-2,2)),math.rad(22.1+math.random(-2,2))),lerp)
				RH.C0=RH.C0:Lerp(cf(0.9,-1.1,-0.2)*angles(math.rad(36.3),math.rad(-16.7),math.rad(10.8))*angles(math.rad(0),math.rad(90),math.rad(0)),.1)
				LH.C0=LH.C0:Lerp(cf(-0.9,-1,-0.2)*angles(math.rad(33),math.rad(17.9),math.rad(-15.5))*angles(math.rad(0),math.rad(-90),math.rad(0)),.1)
			else
				RootJoint.C0=RootJoint.C0:Lerp(cf(0,height,-0.3)*angles(math.rad(-35.5),math.rad(0),math.rad(0))*RootCF,.1)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0,0.1,0.4)*angles(math.rad(-27.1),math.rad(math.random(-2,2)),math.rad(math.random(-2,2)))*necko,lerp)
				RS.C0=RS.C0:Lerp(cf(1.1,0.1,-0.5)*angles(math.rad(161.1+math.random(-2,2)),math.rad(-4.6+math.random(-2,2)),math.rad(-32.5+math.random(-2,2))),lerp)
				LS.C0=LS.C0:Lerp(cf(-0.9,0.3,-0.5)*angles(math.rad(166.3+math.random(-2,2)),math.rad(-6.3+math.random(-2,2)),math.rad(22.1+math.random(-2,2))),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.9,-0.4,-1.1)*angles(math.rad(-54.9),math.rad(13.1),math.rad(-3.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.9,-1,-0.3)*angles(math.rad(-31.5),math.rad(-35.8),math.rad(0.6))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			end
		elseif anim.Value == "SWITCH" then
			local lerp = .1
			if height == 0 then
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,0,0)*angles(math.rad(-19.5),math.rad(0),math.rad(0)),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(-49.5),math.rad(0),math.rad(0)),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(-90)),lerp)
				RS.C0=RS.C0:Lerp(cf(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(90)),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.9,-0.9,-0.1)*angles(math.rad(-22),math.rad(17.9),math.rad(-15.5))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.9,-0.9,0)*angles(math.rad(-18.7),math.rad(-16.7),math.rad(10.8))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			else
				RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,0,height)*angles(math.rad(-19.5),math.rad(0),math.rad(0)),lerp)
				Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(-49.5),math.rad(0),math.rad(0)),lerp)
				LS.C0=LS.C0:Lerp(cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(-90)),lerp)
				RS.C0=RS.C0:Lerp(cf(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(90)),lerp)
				LH.C0=LH.C0:Lerp(cf(-0.9,-0.4,-1.1)*angles(math.rad(-54.9),math.rad(13.1),math.rad(-3.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
				RH.C0=RH.C0:Lerp(cf(0.9,-1,-0.3)*angles(math.rad(-31.5),math.rad(-35.8),math.rad(0.6))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			end
		elseif anim.Value == "SWING" then
			lerp = .4
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,0,0.5)*angles(math.rad(5.4),math.rad(-25.2),math.rad(0))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0.1,0.2,0.2)*angles(math.rad(-18.7),math.rad(26.7),math.rad(8.4))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.6,0.6,0.7)*angles(math.rad(118.6),math.rad(7.6),math.rad(-2.5)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.6,0.6,-0.1)*angles(math.rad(6.1),math.rad(-9.9),math.rad(-16.5)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.9,-0.8,0.2)*angles(math.rad(-12.1),math.rad(-22.7),math.rad(24.5))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.9,-1,0.2)*angles(math.rad(-5.9),math.rad(36.9),math.rad(-2.9))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "GRAB" then
			lerp = .6
			RootJoint.C0=RootJoint.C0:Lerp(cf(-0.1,0,-0.1)*angles(math.rad(-8.7),math.rad(17.3),math.rad(-6.8))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0.3,0.1,0)*angles(math.rad(4),math.rad(-15.2),math.rad(10.9))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.1,0.7,-1.5)*angles(math.rad(104.8),math.rad(11.3),math.rad(-2.9)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.3,0.5,0)*angles(math.rad(25.5),math.rad(10.5),math.rad(-18.7)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.9,-0.8,0.2)*angles(math.rad(-12.1),math.rad(-22.7),math.rad(24.5))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.6,-0.9,-0.6)*angles(math.rad(6.6),math.rad(1.8),math.rad(-12.3))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "SLAM" then
			lerp = .9
			RootJoint.C0=RootJoint.C0:Lerp(cf(-0.1,-0.6,-0.6)*angles(math.rad(-40.7),math.rad(32.3),math.rad(-7.7))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0,0.1,0.5)*angles(math.rad(-33.7),math.rad(-31.6),math.rad(-8.1))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.7,0.4,-1)*angles(math.rad(48),math.rad(-5.6),math.rad(31.3)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.5,0.5,-0.1)*angles(math.rad(16.1),math.rad(-14.6),math.rad(-39)),lerp)
			RH.C0=RH.C0:Lerp(cf(1.1,-0.7,-0.1)*angles(math.rad(8.2),math.rad(-27.9),math.rad(32.7))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.9,-0.7,-0.8)*angles(math.rad(41.1),math.rad(-16.8),math.rad(-1.3))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "REPRESSIONBOMBCHARGE" then
			lerp = .1
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,-0.2,0)*angles(math.rad(19.2),math.rad(0),math.rad(-30.1)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0.3,0,0.1)*angles(math.rad(10.4),math.rad(14),math.rad(24.2)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.1,0.5,-0.6)*angles(math.rad(-150.1),math.rad(-70.7),math.rad(121.3)),lerp)
			RS.C0=RS.C0:Lerp(cf(1.8,0.9,0.6)*angles(math.rad(-142),math.rad(63.2),math.rad(-131.2)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1.1,-0.8,0)*angles(math.rad(26.2),math.rad(37.7),math.rad(-19.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.8,-1.2,0.1)*angles(math.rad(0),math.rad(-25.5),math.rad(12))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "REPRESSIONBOMBDETONATE" then
			lerp = .5
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,-0.2,0)*angles(math.rad(19.2),math.rad(0),math.rad(-30.1)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0.3,0,0.1)*angles(math.rad(10.4),math.rad(14),math.rad(24.2)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.1,0.5,-0.6)*angles(math.rad(-150.1),math.rad(-70.7),math.rad(121.3)),lerp)
			RS.C0=RS.C0:Lerp(cf(0.7,0.5,-1)*angles(math.rad(-160.2),math.rad(47.4),math.rad(-116)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1.1,-0.8,0)*angles(math.rad(26.2),math.rad(37.7),math.rad(-19.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.8,-1.2,0.1)*angles(math.rad(0),math.rad(-25.5),math.rad(12))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "REPRESSIONCIRCLESSTART" then
			lerp = .2
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,0,-0.1)*angles(math.rad(11.9),math.rad(-.6),math.rad(42.4)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(-18.2),math.rad(8.6),math.rad(-47.3)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.4,0.5,0.3)*angles(math.rad(-27.3),math.rad(-33.6),math.rad(25.3)),lerp)
			RS.C0=RS.C0:Lerp(cf(0.9,0,-0.8)*angles(math.rad(86.1),math.rad(-3.4),math.rad(-74.3)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1,-1.1,0.2)*angles(math.rad(8.4),math.rad(8.7),math.rad(-10.9))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.9,-0.9,0.4)*angles(math.rad(3.9),math.rad(-39.7),math.rad(12.7))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "REPRESSIONCIRCLESEND" then
			lerp = .5
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,0,-0.1)*angles(math.rad(26),math.rad(-11.4),math.rad(-29.6)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(-21.6),math.rad(-6.6),math.rad(30.3)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.4,0.5,0.3)*angles(math.rad(-27.3),math.rad(-33.6),math.rad(25.3)),lerp)
			RS.C0=RS.C0:Lerp(cf(1.3,0.8,-0.7)*angles(math.rad(101.1),math.rad(24.7),math.rad(33.9)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1,-1,0)*angles(math.rad(-13.3),math.rad(30.5),math.rad(0.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(1,-0.8,-0.2)*angles(math.rad(14.3),math.rad(10.6),math.rad(16.7))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "TELEPORT" then
			lerp = .08
			local addition = 0
			if height == 0 then addition = 2 end
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,0,height+addition)*angles(math.rad(-2.7),math.rad(-16.9),math.rad(-32)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(27),math.rad(28.1),math.rad(25.4)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.6,0.4,0.4)*angles(math.rad(47.1),math.rad(-6.7),math.rad(-28.4)),lerp)
			RS.C0=RS.C0:Lerp(cf(1.6,0.9,-0.3)*angles(math.rad(155.2),math.rad(48.8),math.rad(0.1)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1,-1.1,-0.3)*angles(math.rad(-28.2),math.rad(20.3),math.rad(4.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.9,0.1,-1.2)*angles(math.rad(-33.4),math.rad(-15.1),math.rad(5.1))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "PowerFall" then
			lerp = .05
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,-0.2,-0.2)*angles(math.rad(66.4),math.rad(0),math.rad(-47.3)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(21),math.rad(14.1),math.rad(42.8)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.3,-0.4,0.1)*angles(math.rad(126.3),math.rad(-58.8),math.rad(-40.9)),lerp)
			RS.C0=RS.C0:Lerp(cf(1.9,1,0.3)*angles(math.rad(155.3),math.rad(56.7),math.rad(-84.8)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1,-1.4,0.3)*angles(math.rad(-114.4),math.rad(-1.5),math.rad(34.3))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.6,-0.1,-1)*angles(math.rad(-19.6),math.rad(-3),math.rad(31.1))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "PowerHit" then
			lerp = .99
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(-0.2,-0.2,-0.7)*angles(math.rad(44.4),math.rad(-32.2),math.rad(39.6)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(76.3),math.rad(-34.8),math.rad(-26.9)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.3,-0.4,0.1)*angles(math.rad(126.3),math.rad(-58.8),math.rad(-40.9)),lerp)
			RS.C0=RS.C0:Lerp(cf(1.5,0.3,0.1)*angles(math.rad(-29.5),math.rad(44.4),math.rad(93.8)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.6,-0.6,0)*angles(math.rad(-43.7),math.rad(32.4),math.rad(-26.9))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.7,0.2,-0.2)*angles(math.rad(32.7),math.rad(-30.6),math.rad(44.5))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "ExecutionGrab" then
			lerp = .5
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,-.1,0)*angles(math.rad(13),math.rad(4.5),math.rad(-26.3)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(6.6),math.rad(-8.1),math.rad(-41.7)),lerp)
			LS.C0=LS.C0:Lerp(cf(0.8,0.2,-1.4)*angles(math.rad(106.4),math.rad(-16.1),math.rad(97)),lerp)
			RS.C0=RS.C0:Lerp(cf(1.6,0,-0.1)*angles(math.rad(69.9),math.rad(2.4),math.rad(55.7)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.8,-0.4,-0.1)*angles(math.rad(27.4),math.rad(38.6),math.rad(-18.8))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(1,-1,0)*angles(math.rad(-7),math.rad(-13.3),math.rad(2))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "ExecutionThrow" then
			lerp = .5
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0.2,.5,0)*angles(math.rad(12.1),math.rad(13.7),math.rad(15.7)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(-37),math.rad(5.3),math.rad(-36.4)),lerp)
			LS.C0=LS.C0:Lerp(cf(-0.4,1.7,-1)*angles(math.rad(-165.7),math.rad(6.7),math.rad(-0.5)),lerp)
			RS.C0=RS.C0:Lerp(cf(1.3,1.4,-0.4)*angles(math.rad(-179.2),math.rad(45.5),math.rad(25.5)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.6,-0.2,-0.7)*angles(math.rad(1),math.rad(-12.9),math.rad(-23.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.9,-1,-0.3)*angles(math.rad(-28.9),math.rad(-23.9),math.rad(4))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "ExecutionCharge" then
			lerp = .5
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,0.3,-0.1)*angles(math.rad(-39.1),math.rad(0),math.rad(0)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(-57.9),math.rad(0),math.rad(0)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1,1.3,1.1)*angles(math.rad(-117.3),math.rad(26.6),math.rad(32.3)),lerp)
			RS.C0=RS.C0:Lerp(cf(1,1.3,1)*angles(math.rad(-109.5),math.rad(-17.8),math.rad(-24.4)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.8,-0.9,-1.1)*angles(math.rad(-73.8),math.rad(13.9),math.rad(-11.5))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(1,-0.9,0)*angles(math.rad(-30.2),math.rad(-9.9),math.rad(5.7))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "ExecutionSlam" then
			lerp = .9
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,0,0.2)*angles(math.rad(20.5),math.rad(0),math.rad(0)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(15.4),math.rad(0),math.rad(0)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1,0.9,-0.9)*angles(math.rad(84.5),math.rad(26.6),math.rad(32.3)),lerp)
			RS.C0=RS.C0:Lerp(cf(1,0.9,-0.8)*angles(math.rad(92.4),math.rad(-17.8),math.rad(-24.4)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.8,-0.9,-1.1)*angles(math.rad(-73.8),math.rad(13.9),math.rad(-11.5))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(1,-0.9,0)*angles(math.rad(-30.2),math.rad(-9.9),math.rad(5.7))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "RESTING" then
			lerp = .05
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(-0.3,0.5,height-0.1+.2*cs(40))*angles(math.rad(-58.3+3*cs(70)),math.rad(39.1+8*cs(78)),math.rad(25.7+8*cs(67))),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,-.2,.3)*angles(math.rad(66.7),math.rad(-17.8+10*cs(80)),math.rad(9.1)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.4-.1*cs(80),1.2,-0.1+.1*cs(80))*angles(math.rad(122.5),math.rad(0),math.rad(46.7-5*cs(80))),lerp)
			RS.C0=RS.C0:Lerp(cf(0.8,0.5,0.8+.3*math.sin(sine/40))*angles(math.rad(-80.3+5*cs(59)),math.rad(-4.3+5*cs(54)),math.rad(-40.4+5*cs(47))),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.8,-0.9,-0.2)*angles(math.rad(-34.4+10*math.sin(sine/40)),math.rad(9.1),math.rad(-37.3))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(1,-1.5,0)*angles(math.rad(-22.9+10*math.sin(sine/40)),math.rad(-11.1),math.rad(-54.6))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "FLAMETHROWERSTART" then
			lerp = .1
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(-0.1,0.6,-0.7)*angles(math.rad(-25),math.rad(10.4),math.rad(-23.1)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(30.2),math.rad(-3.3),math.rad(21.2)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.3,1.2,-0.7)*angles(math.rad(169.7),math.rad(6.9),math.rad(16)),lerp)
			RS.C0=RS.C0:Lerp(cf(1.3,1.2,-0.7)*angles(math.rad(178.6),math.rad(-8.7),math.rad(-13.9)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1,-0.8,-0.7)*angles(math.rad(-11.4),math.rad(26.7),math.rad(-13.5))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.7,-1.1,-0.6)*angles(math.rad(-58.6),math.rad(-16.9),math.rad(11))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "FLAMETHROWEREND" then
			lerp = .7
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(-0.1,-0.7,-0.4)*angles(math.rad(11.1),math.rad(10.4),math.rad(-23.1)),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*cf(0,0,0)*angles(math.rad(-17.9),math.rad(-14.7),math.rad(13.1)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1,1.1,-0.3)*angles(math.rad(90.1),math.rad(-1),math.rad(-8.3)),lerp)
			RS.C0=RS.C0:Lerp(cf(0.7,0.8,-1.1)*angles(math.rad(91.8),math.rad(-18.8),math.rad(-38.5)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.6,-0.6,0.2)*angles(math.rad(26.9),math.rad(19),math.rad(-27.6))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(1,-1.4,0.1)*angles(math.rad(-29.4),math.rad(-11.4),math.rad(-3.5))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
		elseif anim.Value == "HADOUKENSTART" then
			lerp = .3
			RootJoint.C0=RootJoint.C0:Lerp(cf(0.3,-0.3,-0.5)*angles(math.rad(-40.8),math.rad(-55.6),math.rad(-26.3))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0.1,0,-0.1)*angles(math.rad(0),math.rad(64.8),math.rad(5.3))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.4,0.7,0.3)*angles(math.rad(53.8),math.rad(60),math.rad(47)),lerp)
			LS.C0=LS.C0:Lerp(cf(-0.7,0.2,-0.8)*angles(math.rad(88.9),math.rad(-3),math.rad(67.9)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.9,-1.3,0.1)*angles(math.rad(12.4),math.rad(-29.9),math.rad(16.5))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1,-1,0.4)*angles(math.rad(19.6),math.rad(63.7),math.rad(-12.8))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "HADOUKENEND" then
			lerp = .8
			RootJoint.C0=RootJoint.C0:Lerp(cf(0.3,-0.3,-0.8)*angles(math.rad(-31.5),math.rad(-45),math.rad(-14.2))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(-0.1,0,-0.1)*angles(math.rad(5.5),math.rad(51),math.rad(-3.7))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(0,0.8,-1.3)*angles(math.rad(108),math.rad(-12.2),math.rad(-48.8)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.4,0.6,-0.2)*angles(math.rad(109.7),math.rad(-7.8),math.rad(-45.1)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.9,-1.3,0.1)*angles(math.rad(12.4),math.rad(-29.9),math.rad(16.5))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1,-1,0.4)*angles(math.rad(19.6),math.rad(63.7),math.rad(-12.8))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "VINDICTIVE Z" then
			local lerp = .05
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,5,0.3)*angles(math.rad(39.9),math.rad(0),math.rad(0))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0,0.1,0.6)*angles(math.rad(-36.9),math.rad(0),math.rad(0))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.1,0.5,-0.5)*angles(math.rad(93.8),math.rad(0),math.rad(-40.1)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1,0.6,-0.6)*angles(math.rad(111.1),math.rad(0),math.rad(40.1)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.6,0.2,-0.9)*angles(math.rad(-3.6),math.rad(-14.8),math.rad(22.9))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.8,-0.9,0.1)*angles(math.rad(0),math.rad(21.6),math.rad(-15.3))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "VINDICTIVE Z END" then
			local lerp = .8
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,5,0.3)*angles(math.rad(59.4+math.random(-2,2)),math.rad(math.random(-2,2)),math.rad(math.random(-2,2)))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0,0.4,-0.8)*angles(math.rad(54.5+math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5)))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.6,0.5,-0.1)*angles(math.rad(126.9+math.random(-5,5)),math.rad(2.5+math.random(-5,5)),math.rad(86.5+math.random(-5,5))),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.6,0.6,0)*angles(math.rad(116.1+math.random(-5,5)),math.rad(-5.2+math.random(-5,5)),math.rad(-90.5+math.random(-5,5))),lerp)
			RH.C0=RH.C0:Lerp(cf(0.6,0.2,-0.9)*angles(math.rad(-3.6+math.random(-5,5)),math.rad(-14.8+math.random(-5,5)),math.rad(22.9+math.random(-5,5)))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.8,-0.9,0.1)*angles(math.rad(math.random(-5,5)),math.rad(21.6+math.random(-5,5)),math.rad(-15.3+math.random(-5,5)))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "Ground Stomp 1" then
			local lerp = .1
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,0,1)*angles(math.rad(23.7),math.rad(29.2),math.rad(-4.7))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(-0.2,0.4,0.8)*angles(math.rad(-44.1),math.rad(-20.2),math.rad(-12.3))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.6,0.6,0)*angles(math.rad(0),math.rad(0),math.rad(22.7)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.6,0.7,0)*angles(math.rad(-9.5),math.rad(0),math.rad(-16.2)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.8,0.4,-0.8)*angles(math.rad(-2.7),math.rad(-17.1),math.rad(14.5))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1.1,-0.9,0.2)*angles(math.rad(-22.9),math.rad(22.4),math.rad(-6.7))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "Ground Stomp 2" then
			local lerp = .99
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,-0.3,-0.2)*angles(math.rad(-11.2),math.rad(29.2),math.rad(-4.7))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0,0.1,0.4)*angles(math.rad(-25.2),math.rad(-22.9),math.rad(-5.2))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.6,0.6,0)*angles(math.rad(0),math.rad(0),math.rad(70.2)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.5,0.8,-0.1)*angles(math.rad(-9.5),math.rad(0),math.rad(-72.1)),lerp)
			RH.C0=RH.C0:Lerp(cf(1.1,-0.5,-0.5)*angles(math.rad(3.4),math.rad(-32.1),math.rad(9.1))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-1.1,-0.9,0.1)*angles(math.rad(-12.5),math.rad(21.2),math.rad(1.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "Mouse1Start" then
			local lerp = .2
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,height,0)*angles(math.rad(0),math.rad(31.2),math.rad(0))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0,0,0)*angles(math.rad(0),math.rad(-31.2),math.rad(0))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.4,0.7,-0.8)*angles(math.rad(90.6),math.rad(0),math.rad(30.1)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.6,0.6,0)*angles(math.rad(-11),math.rad(-4.5),math.rad(-18.4)),lerp)
			if height == 0 then
				RH.C0=RH.C0:Lerp(cf(1,-1,0)*angles(math.rad(2.7),math.rad(-22.9),math.rad(6.6))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			else
				RH.C0=RH.C0:Lerp(cf(0.9,-1,-0.3)*angles(math.rad(-31.5),math.rad(-35.8),math.rad(0.6))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			end
			LH.C0=LH.C0:Lerp(cf(-0.9,-1,0)*angles(math.rad(-3),math.rad(11.6),math.rad(-4.5))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "Mouse1End" then
			local lerp = .7
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,height,-0.2)*angles(math.rad(-12.5),math.rad(31.2),math.rad(0))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0,0,0)*angles(math.rad(10),math.rad(-31.2),math.rad(0))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.4,0.4,-0.6)*angles(math.rad(-179.6),math.rad(3.8),math.rad(-6.1)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.6,0.5,0)*angles(math.rad(-11),math.rad(-4.5),math.rad(-64.2)),lerp)
			if height == 0 then
				RH.C0=RH.C0:Lerp(cf(0.9,-0.9,0.1)*angles(math.rad(16.1),math.rad(-21.9),math.rad(13.5))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			else
				RH.C0=RH.C0:Lerp(cf(0.9,-1,-0.3)*angles(math.rad(-31.5),math.rad(-35.8),math.rad(0.6))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			end
			LH.C0=LH.C0:Lerp(cf(-0.9,-1.1,0)*angles(math.rad(6.4),math.rad(11.7),math.rad(2.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "Healing Burst Start" then
			local lerp = .1
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,0,-0.2)*angles(math.rad(-5.5),math.rad(0),math.rad(0))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0,0.1,0.4)*angles(math.rad(-27.8),math.rad(0),math.rad(0))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.1,0,-0.5)*angles(math.rad(103),math.rad(14.7),math.rad(-63)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.2,0,-0.3)*angles(math.rad(89.3),math.rad(-7.2),math.rad(49.5)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.9,-1,0.1)*angles(math.rad(6.1),math.rad(-10.9),math.rad(4.7))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.9,-1,0.1)*angles(math.rad(5.2),math.rad(7.5),math.rad(-3.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "Healing Burst End" then
			local lerp = .7
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,0,0.2)*angles(math.rad(11.8),math.rad(0),math.rad(0))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0,0,-0.3)*angles(math.rad(15.2),math.rad(0),math.rad(0))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.6,0.9,-0.2)*angles(math.rad(95.4),math.rad(16.2),math.rad(80.1)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.8,0.8,-0.3)*angles(math.rad(89.6),math.rad(-15.4),math.rad(-65.4)),lerp)
			RH.C0=RH.C0:Lerp(cf(0.9,-0.9,0)*angles(math.rad(-11.1),math.rad(-10.9),math.rad(4.7))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.9,-0.9,0)*angles(math.rad(-12),math.rad(7.5),math.rad(-3.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "Execution Z 1" then
			local lerp = .1
			RootJoint.C0=RootJoint.C0:Lerp(cf(1*cs(80),5-1*math.cos(sine/50),1*cs(70))*angles(math.rad(75.1),math.rad(55.3),math.rad(-52.3))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0.2,0.2,0.6)*angles(math.rad(-11.3),math.rad(-64.8),math.rad(29.1))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.6,0.5,-0.1)*angles(math.rad(-28),math.rad(25.7),math.rad(162.7)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.5,-0.3,-0.2)*angles(math.rad(113.9),math.rad(25.4),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(1,0,-0.7)*angles(math.rad(-19),math.rad(-16.2),math.rad(7.5))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.8,-0.9,0)*angles(math.rad(-46.8),math.rad(9.3),math.rad(-10.3))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "Execution Z 2" then
			local lerp = .1
			RootJoint.C0=RootJoint.C0:Lerp(cf(1*cs(80),5-1*math.cos(sine/50),1*cs(70))*angles(math.rad(75.1),math.rad(55.3),math.rad(-52.3))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0.2,0.2,0.6)*angles(math.rad(-11.3),math.rad(-64.8),math.rad(29.1))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.3,-0.4,0.5)*angles(math.rad(-28),math.rad(25.7),math.rad(162.7)),.99)
			LS.C0=LS.C0:Lerp(cf(-1.5,-0.3,-0.2)*angles(math.rad(113.9),math.rad(25.4),math.rad(0)),lerp)
			RH.C0=RH.C0:Lerp(cf(1,0,-0.7)*angles(math.rad(-19),math.rad(-16.2),math.rad(7.5))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.8,-0.9,0)*angles(math.rad(-46.8),math.rad(9.3),math.rad(-10.3))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "ApexRun" then
			local lerp = .3
			local m = 6
			local n = m/2
			RootJoint.C0=RootJoint.C0:Lerp(RootCF*cf(0,-0.05,-0.05-0.05*math.cos(sine/n)+.05*math.sin(sine/n))*angles(math.rad(10+20+3*math.cos(sine/n)),0,math.rad(4*math.cos(sine/m))),lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(necko*angles(math.rad(-20-7*math.cos(sine / n)),0,math.rad(-3*math.cos(sine/m))),lerp)
			RS.C0=RS.C0:Lerp(cf(1.3,0.1,0.3)*angles(math.rad(0),math.rad(-54.3),math.rad(50.3)),lerp)
			LS.C0=LS.C0:Lerp(cf(-0.8,0.8,-1)*angles(math.rad(105.9),math.rad(-13.6),math.rad(81.1)),lerp)
			RH.C0=RH.C0:Lerp(cf(1,-.8+.5*math.sin(sine/-m),0-.25*math.cos(sine/m)-0.2)*angles(0,math.rad(90),0)*angles(0,math.rad(-8*math.cos(sine/m)),math.rad(10+65*math.cos(sine / m))),lerp)
			LH.C0=LH.C0:Lerp(cf(-1,-.8+.5*math.sin(sine/m),0+.25*math.cos(sine/m)-0.2)*angles(0,math.rad(-90),0)*angles(0,math.rad(-8*math.cos(sine/m)),math.rad(10+65*math.cos(sine / m))),lerp)
		elseif anim.Value == "Coin Toss 1" then
			local lerp = .3
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,height-1,-0.1)*angles(math.rad(30.4),math.rad(-12.2),math.rad(7.1))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(-0.1,0.3,0.6)*angles(math.rad(-38.4),math.rad(-26.3),math.rad(-3.9))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.3,0.2,0.1)*angles(math.rad(58.5),math.rad(-3.6),math.rad(-24.9)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.3,0.2,-0.5)*angles(math.rad(63.9),math.rad(-18.1),math.rad(67.1)),lerp)
			RH.C0=RH.C0:Lerp(cf(1.1,-0.7,-1.3)*angles(math.rad(-55.1),math.rad(-21.2),math.rad(9.4))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.7,-0.8,-0.2)*angles(math.rad(-43.3),math.rad(13.6),math.rad(-14.6))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		elseif anim.Value == "Coin Toss 2" then
			local lerp = .3
			RootJoint.C0=RootJoint.C0:Lerp(cf(0.1,height,-0.2)*angles(math.rad(32.9),math.rad(24.4),math.rad(-14.9))*RootCF,lerp)
			Torso.Neck.C0=Torso.Neck.C0:Lerp(cf(0.2,0,0)*angles(math.rad(-8),math.rad(-24.9),math.rad(10.3))*necko,lerp)
			RS.C0=RS.C0:Lerp(cf(1.1,0,-0.4)*angles(math.rad(109.6),math.rad(7),math.rad(10.1)),lerp)
			LS.C0=LS.C0:Lerp(cf(-1.3,0.2,-0.5)*angles(math.rad(63.9),math.rad(-18.1),math.rad(67.1)),lerp)
			RH.C0=RH.C0:Lerp(cf(1.1,-0.7,-1.3)*angles(math.rad(-55.1),math.rad(-21.2),math.rad(9.4))*angles(math.rad(0),math.rad(90),math.rad(0)),lerp)
			LH.C0=LH.C0:Lerp(cf(-0.7,-0.8,-0.2)*angles(math.rad(-43.3),math.rad(13.6),math.rad(-14.6))*angles(math.rad(0),math.rad(-90),math.rad(0)),lerp)
		end
	end
end

local rs = game:GetService("RunService")
local inputs = game:GetService("UserInputService")
local tweens = game:GetService("TweenService")
local plr = game.Players.LocalPlayer.Character
local script = plr
local Loud = 0
local LocalLoudness = 0
local mouse = game:GetService("Players").LocalPlayer:GetMouse()
mouse.TargetFilter = workspace:WaitForChild("LastStarMouseIgnore")

wait(.1)
--[[if workspace:FindFirstChild("LastStarPlace") then
	local light = Instance.new("ColorCorrectionEffect",game:GetService("Lighting"))
	game:GetService("Debris"):AddItem(light,3)
	light.Contrast = -2
	light.Brightness = 1
	local info = TweenInfo.new(.5,Enum.EasingStyle.Sine,Enum.EasingDirection.Out,0,false,0)
	local prop = {Brightness=0}
	local tween = tweens:Create(light,info,prop)
	tween:Play()
	wait(1)
	light.TintColor = Color3.fromRGB(255,0,0)
	local info = TweenInfo.new(2,Enum.EasingStyle.Quint,Enum.EasingDirection.In,0,false,0)
	local prop = {Contrast=0;TintColor=Color3.fromRGB(255,255,255)}
	local tween = tweens:Create(light,info,prop)
	tween:Play()
end]]

local gui = game.Players.LocalPlayer.PlayerGui.PlayerGui

gui:WaitForChild("HelpMenu")
gui.HelpButton.MouseButton1Click:Connect(function()
	if gui.HelpMenu.Visible == false then
		gui.HelpMenu.Visible = true
	else
		gui.HelpMenu.Visible = false
	end
end)

script:WaitForChild("Events"):WaitForChild("TweenRoot").OnClientEvent:Connect(function(tim,style,direction,prop)
	local info = TweenInfo.new(tim,style,direction,0,false,0)
	local tween = tweens:Create(script.Parent.Parent:WaitForChild("HumanoidRootPart"),info,prop)
	tween:Play()
end)

gui:WaitForChild("HelpMenu"):WaitForChild("BG"):WaitForChild("UpdateList"):WaitForChild("MouseFrame"):WaitForChild("ListCrop"):WaitForChild("ListBG").Parent:WaitForChild("ListContent")

local totalupdatesize = 0
local updatequeue = {}
for i,v in ipairs(gui.HelpMenu.BG.UpdateList.MouseFrame.ListCrop.ListContent:GetChildren()) do
	local up = string.split(v.Name,"")
	v:WaitForChild("Update")
	v.Update.Text = "v"..up[1].."."..up[2].."."..up[3]
	v.Size = UDim2.new(1,0,0,v:WaitForChild("Contents").TextBounds.Y+30)
	local f = Instance.new("Frame",gui.HelpMenu.BG.UpdateList.MouseFrame.ListCrop.ListBG)
	f.Name = v.Name
	f.Size = v.Size
	f.BackgroundTransparency = 1
	totalupdatesize += v.Contents.TextBounds.Y+40
	local pos = Instance.new("NumberValue",f)
	pos.Name = "Pos"
	table.insert(updatequeue,#updatequeue+1,v)
end
gui.HelpMenu.BG.UpdateList.MouseFrame.ListCrop.ListBG.Size = UDim2.new(1,0,0,totalupdatesize)
gui.HelpMenu.BG.UpdateList.MouseFrame.ListCrop.ListContent.Size = UDim2.new(1,0,0,totalupdatesize)

game:GetService("Players").LocalPlayer.CameraMaxZoomDistance = 100000
local updatescrolling = false
gui.HelpMenu.BG.UpdateList.MouseFrame.MouseEnter:Connect(function()
	updatescrolling = true
	local mag = (script.Parent.Parent.HumanoidRootPart.Position-workspace.CurrentCamera.CFrame.Position).Magnitude
	game:GetService("Players").LocalPlayer.CameraMaxZoomDistance = mag
	game:GetService("Players").LocalPlayer.CameraMinZoomDistance = mag
end)
gui.HelpMenu.BG.UpdateList.MouseFrame.MouseLeave:Connect(function()
	updatescrolling = false
	game:GetService("Players").LocalPlayer.CameraMaxZoomDistance = 100000
	game:GetService("Players").LocalPlayer.CameraMinZoomDistance = 0
end)
local info = TweenInfo.new(.3,Enum.EasingStyle.Quint,Enum.EasingDirection.Out,0,false,0)
mouse.WheelForward:Connect(function()
	if updatescrolling == true then
		local prop = {Value=math.clamp(gui.UpdateScroll.Value+125,-totalupdatesize,0)}
		local tween = tweens:Create(gui.UpdateScroll,info,prop)
		tween:Play()
	end
end)
mouse.WheelBackward:Connect(function()
	if updatescrolling == true then
		local prop = {Value=math.clamp(gui.UpdateScroll.Value-125,-totalupdatesize,0)}
		local tween = tweens:Create(gui.UpdateScroll,info,prop)
		tween:Play()
	end
end)
gui:WaitForChild("HelpMenu"):WaitForChild("BG"):WaitForChild("UpdateList"):WaitForChild("Up")
gui.HelpMenu.BG.UpdateList.Up.MouseButton1Click:Connect(function()
	local prop = {Value=math.clamp(gui.UpdateScroll.Value+200,-totalupdatesize,0)}
	local tween = tweens:Create(gui.UpdateScroll,info,prop)
	tween:Play()
end)
gui:WaitForChild("HelpMenu"):WaitForChild("BG"):WaitForChild("UpdateList"):WaitForChild("Down")
gui.HelpMenu.BG.UpdateList.Down.MouseButton1Click:Connect(function()
	local prop = {Value=math.clamp(gui.UpdateScroll.Value-200,-totalupdatesize,0)}
	local tween = tweens:Create(gui.UpdateScroll,info,prop)
	tween:Play()
end)

local reversequeue = {}
for i = 1,#updatequeue do
	table.insert(reversequeue,#reversequeue+1,i)
end
for i,v in pairs(updatequeue) do
	table.insert(reversequeue,1,v)
end
for x = 1,50 do
	for i,v in ipairs(reversequeue) do
		if typeof(v) ~= "Instance" then
			table.remove(reversequeue,i)
		end
	end
end
local lastoffset = 0
for i,v in ipairs(reversequeue) do
	local f = gui.HelpMenu.BG.UpdateList.MouseFrame.ListCrop.ListBG:FindFirstChild(v.Name)
	f:WaitForChild("Pos").Value = lastoffset
	lastoffset += v.Contents.TextBounds.Y+50
end
function change(rules,instructions,updates)
	gui.HelpMenu.BG.Rules.Visible = rules
	gui.HelpMenu.BG.Instructions.Visible = instructions
	gui.HelpMenu.BG.UpdateList.Visible = updates
end
gui.HelpMenu.BG.RulesButton.MouseButton1Click:Connect(function()
	change(true,false,false)
end)
gui.HelpMenu.BG.InstructionsButton.MouseButton1Click:Connect(function()
	change(false,true,false)
end)
gui.HelpMenu.BG.UpdatesButton.MouseButton1Click:Connect(function()
	change(false,false,true)
end)

local thumbstickframe = nil
local isonthumbstick = false
if inputs.MouseEnabled == false and inputs.KeyboardEnabled == false and inputs.TouchEnabled == true then
	gui:WaitForChild("MobileFormChange").Visible=true
	gui:WaitForChild("MobileSongMute").Visible=true
	for i,v in pairs(gui.MobileAttacks:GetChildren()) do
		v.Visible=true
	end
	game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("TouchGui").DisplayOrder = 1
end

local chosenmove = Enum.KeyCode.Return
local chosenleftclick = 0

gui:WaitForChild("MobileAttacks")
for i,v in ipairs(gui.MobileAttacks:GetChildren()) do
	local info = TweenInfo.new(.1,Enum.EasingStyle.Sine,Enum.EasingDirection.Out)
	local prop1,prop2 = {Value=1},{Value=0}
	local tween1,tween2 = tweens:Create(v.Border,info,prop1),tweens:Create(v.Border,info,prop2)
	v.MouseButton1Click:Connect(function()
		if v.SelectedBool.Value == false then
			v.SelectedBool.Value = true
			if inputs.MouseEnabled == false and inputs.KeyboardEnabled == false and inputs.TouchEnabled == true then
				if i == 1 then
					chosenmove = Enum.KeyCode.C
					chosenleftclick = 0
				elseif i == 2 then
					chosenmove = Enum.KeyCode.F
					chosenleftclick = 0
				elseif i == 3 then
					chosenmove = Enum.KeyCode.V
					chosenleftclick = 0
				elseif i == 4 then
					chosenmove = Enum.KeyCode.Z
					chosenleftclick = 0
				elseif i == 5 then
					chosenmove = Enum.KeyCode.X
					chosenleftclick = 0
				elseif i == 7 then
					chosenmove = Enum.KeyCode.One
					chosenleftclick = 1
					script.Parent.Events.Key:FireServer(chosenmove,"on")
				elseif i == 6 then
					chosenmove = Enum.KeyCode.Two
					chosenleftclick = 2
					script.Parent.Events.Key:FireServer(chosenmove,"on")
				elseif i == 8 then
					chosenmove = Enum.KeyCode.Three
					chosenleftclick = 3
					script.Parent.Events.Key:FireServer(chosenmove,"on")
				end
				tween1:Play()
				for z,x in pairs(gui.MobileAttacks:GetChildren()) do
					local tween = tweens:Create(x.Border,info,prop2)
					if x ~= v then
						x.SelectedBool.Value = false
						tween:Play()
					end
				end
			end
		else
			v.SelectedBool.Value = false
			tween2:Play()
			chosenmove = Enum.KeyCode.Return
			chosenleftclick = 0
		end
	end)
end

function checkmouse()
	local t = mouse.Target
	if mouse.Target then
		if mouse.Target.Name == "HitboxExtension" then
			t = mouse.Target.Parent
		end
	end
	local dist = (workspace.CurrentCamera.CFrame.Position-mouse.Hit.Position).Magnitude
	local torso = script.Parent.Parent:WaitForChild("Torso")
	local LA,RA,head,LL,RL = script.Parent.Parent:WaitForChild("Left Arm"),script.Parent.Parent:WaitForChild("Right Arm"),script.Parent.Parent:WaitForChild("Head"),script.Parent.Parent:WaitForChild("Left Leg"),script.Parent.Parent:WaitForChild("Right Leg")
	if dist <= 2048 then
		script.Parent.Events.MouseCFrame:FireServer(mouse.Hit,t,torso.CFrame,LA.CFrame,RA.CFrame,head.CFrame,LL.CFrame,RL.CFrame)
	else
		local raypart,raypos,ray = nil,nil,nil
		local dir = (mouse.Hit.Position-workspace.CurrentCamera.CFrame.Position).Unit*5000
		local rayposstart = CFrame.new(workspace.CurrentCamera.CFrame.Position,(mouse.Hit.Position-workspace.CurrentCamera.CFrame.Position))
		local ray = Ray.new(rayposstart.Position,dir)
		local r,p,n = workspace:FindPartOnRayWithIgnoreList(ray,{game:GetService("Players").LocalPlayer.Character,workspace:WaitForChild("LastStarMouseIgnore")},false,true)
		if p then
			script.Parent.Events.MouseCFrame:FireServer(CFrame.new(p),r,torso.CFrame,LA.CFrame,RA.CFrame,head.CFrame,LL.CFrame,RL.CFrame)
		end
	end
end

inputs.TouchStarted:Connect(function(input,aaa)
	if not aaa then
		if thumbstickframe then
			if mouse.Y < (thumbstickframe.AbsolutePosition.Y-thumbstickframe.AbsoluteSize.Y)*-1 or mouse.X > thumbstickframe.AbsolutePosition.X+thumbstickframe.AbsoluteSize.X then
				checkmouse()
				if chosenleftclick == 0 then
					script.Parent.Events.Key:FireServer(chosenmove,"on")
				else
					script.Parent.Events.Key:FireServer("mousebutton1","on")
				end
			end
		end
	end
end)
inputs.TouchEnded:Connect(function(input,aaa)
	if not aaa then
		checkmouse()
		script.Parent.Events.Key:FireServer(chosenmove,"off")
	end
end)

inputs.InputBegan:Connect(function(key,aaa)
	if not aaa then
		if key.UserInputType == Enum.UserInputType.Keyboard then
			script.Events.Key:FireServer(key.KeyCode,"on")
			if key.KeyCode == Enum.KeyCode.One or key.KeyCode == Enum.KeyCode.Two or key.KeyCode == Enum.KeyCode.Three then
				local click = "1"
				if key.KeyCode == Enum.KeyCode.Two then
					click = "2"
				elseif key.KeyCode == Enum.KeyCode.Three then
					click = "3"
				end
				for i,v in ipairs(gui.MobileAttacks:GetChildren()) do
					local info = TweenInfo.new(.1,Enum.EasingStyle.Sine,Enum.EasingDirection.Out)
					local prop1,prop2 = {Value=1},{Value=0}
					local tween1,tween2 = tweens:Create(v.Border,info,prop1),tweens:Create(v.Border,info,prop2)
					if v.Name == click then
						tween1:Play()
						v.SelectedBool.Value = true
						for z,x in pairs(gui.MobileAttacks:GetChildren()) do
							local tween = tweens:Create(x.Border,info,prop2)
							if x ~= v then
								x.SelectedBool.Value = false
								tween:Play()
							end
						end
					else
						v.SelectedBool.Value = false
						tween2:Play()
						chosenmove = Enum.KeyCode.Return
						chosenleftclick = 0
					end
				end
			end
			if key.KeyCode == Enum.KeyCode.Comma then
				if inputs.MouseIconEnabled == true then
					inputs.MouseIconEnabled = false
				else
					inputs.MouseIconEnabled = true
				end
			end
		elseif key.UserInputType == Enum.UserInputType.MouseButton1 then
			script.Parent.Events.Key:FireServer("mousebutton1","on")
		end
	end
end)
inputs.InputEnded:Connect(function(key)
	if key.UserInputType == Enum.UserInputType.Keyboard then
		script.Events.Key:FireServer(key.KeyCode,"off")
	elseif key.UserInputType == Enum.UserInputType.MouseButton1 then
		script.Events.Key:FireServer("mousebutton1","off")
	end
end)

coroutine.resume(coroutine.create(function()
	while true do
		wait(1)
		for i,v in pairs(workspace:GetDescendants()) do
			if v:IsA("Humanoid") and v.Parent ~= script.Parent.Parent then
				for _,c in pairs(v.Parent:GetChildren()) do
					if c:IsA("Part") and c.Parent.Name ~= "TeleportEffect" then
						local d = c:FindFirstChild("HitboxExtension")
						local p = Instance.new("Part",c)
						p.Name = "HitboxExtension"
						p.Massless = true
						p.Size = c.Size+Vector3.new(6,6,6)
						local w = Instance.new("Weld",p)		w.Part0 = p		w.Part1 = c
						p.CanCollide=false
						p.Anchored=false
						p.Transparency = 1
						if d then
							d:Destroy()
						end
					end
				end
			end
		end
	end
end))
script.Events:WaitForChild("MouseCFrame")
repeat
	wait()
until game:GetService("Players").LocalPlayer.Character
coroutine.resume(coroutine.create(function()
	while true do
		wait()
		for i,v in pairs(gui.MobileAttacks:GetChildren()) do
			local cd = script.Cooldowns:FindFirstChild(v.Name).Cooldown
			v.Charge.BackgroundColor3 = v.BorderColor3
			if cd.Value < 1 then
				v.Charge.BackgroundTransparency = .5
				v.Charge.Size = UDim2.new(1,0,1,0)
				local info = TweenInfo.new(.012,Enum.EasingStyle.Sine,Enum.EasingDirection.Out,0,false,0)
				local prop = {Size = UDim2.new(1,0,1-(cd.Value),0)}
				local tween = tweens:Create(v.Charge,info,prop)
				tween:Play()
			else
				v.Charge.BackgroundTransparency = 1
			end
		end
		local t = mouse.Target
		if mouse.Target then
			if mouse.Target.Name == "HitboxExtension" then
				t = mouse.Target.Parent
			end
		end
		local dist = (workspace.CurrentCamera.CFrame.Position-mouse.Hit.Position).Magnitude
		local torso = script:WaitForChild("Torso")
		local LA,RA,head,LL,RL = script:WaitForChild("Left Arm"),script:WaitForChild("Right Arm"),script:WaitForChild("Head"),script:WaitForChild("Left Leg"),script:WaitForChild("Right Leg")
		if dist <= 2048 then
			script.Events.MouseCFrame:FireServer(mouse.Hit,t,torso.CFrame,LA.CFrame,RA.CFrame,head.CFrame,LL.CFrame,RL.CFrame)
		else
			local raypart,raypos,ray = nil,nil,nil
			local dir = (mouse.Hit.Position-workspace.CurrentCamera.CFrame.Position).Unit*5000
			local rayposstart = CFrame.new(workspace.CurrentCamera.CFrame.Position,(mouse.Hit.Position-workspace.CurrentCamera.CFrame.Position))
			local ray = Ray.new(rayposstart.Position,dir)
			local r,p,n = workspace:FindPartOnRayWithIgnoreList(ray,{game:GetService("Players").LocalPlayer.Character,workspace:WaitForChild("LastStarMouseIgnore")},false,true)
			if p then
				script.Events.MouseCFrame:FireServer(CFrame.new(p),r,torso.CFrame,LA.CFrame,RA.CFrame,head.CFrame,LL.CFrame,RL.CFrame)
			end
		end
	end
end))



-- GUI

function transform(seconds)
	seconds = math.floor(seconds+.5)
	local minutes,extra = 0,""
	
	if seconds >= 60 then
		repeat
			if seconds >= 60 then
				seconds = seconds - 60
				minutes = minutes + 1
			end
		until seconds < 60
	end
	if seconds < 10 then
		extra = "0"
	end
	return(minutes..":"..extra..seconds)
end

gui.Parent = game:GetService("Players").LocalPlayer.PlayerGui

local aiming = false
gui:WaitForChild("Music"):WaitForChild("Button")
gui.Music.Button.MouseEnter:Connect(function()
	gui.Music.HighLight.BackgroundTransparency = .5
	gui.Music.HighLight.Glow1.BackgroundTransparency = .75
	aiming = true
end)
gui.Music.Button.MouseLeave:Connect(function()
	gui.Music.HighLight.BackgroundTransparency = 1
	gui.Music.HighLight.Glow1.BackgroundTransparency = 1
	aiming = false
end)

local sine = 0
local c3 = Color3.fromRGB

local p,s = c3(0,0,0),c3(0,0,0)

local namegui = script:WaitForChild("Head"):WaitForChild("NameGui")
local theme = script:WaitForChild("HumanoidRootPart"):WaitForChild("Theme")
local offset = 0
local d = workspace:WaitForChild("LastStarMouseIgnore")
function effect(shape,cframe,sizevector,color,material,transparency,tweentime,easingstyle,easingdirection,reverse,tableprop,newtransparency,transparencystyle)
	local s = d:FindFirstChild(shape)
	local count = 0
	for i,v in pairs(d:GetChildren()) do
		if v.Name == "EFFECTLIMITER" then
			count += 1
		end
	end
	local enableeff = true
	if script.Parent:FindFirstChild("LastStar") then
		if count > script.Parent.LastStar.Settings.EffectLimit.Value-1 then
			enableeff = false
		end
	end
	if enableeff == true then
		if s then
			local h = s:Clone()
			local a = 1
			if reverse == true then
				a = 2
			end
			if h then
				local limitindicator = Instance.new("StringValue",d)
				limitindicator.Name = "EFFECTLIMITER"
				game:GetService("Debris"):AddItem(limitindicator,tweentime*a)
				game:GetService("Debris"):AddItem(h,tweentime*a)
				h.Name = "EFFECT"
				h.Parent = d
				h.CFrame = cframe
				h.Size = sizevector
				h.Color = color
				h.Material = material
				h.Anchored=true
				h.CanCollide=false
				h.CastShadow=false
				h.Massless=true
				h.Transparency=transparency
				local info = TweenInfo.new(tweentime,easingstyle,easingdirection,0,reverse,0)
				local prop = tableprop
				local tween = tweens:Create(h,info,prop)
				tween:Play()
				local transparencyinfo = TweenInfo.new(tweentime,transparencystyle,easingdirection,0,reverse,0)
				local transparencyprop = {Transparency=newtransparency}
				local transparencytween = tweens:Create(h,transparencyinfo,transparencyprop)
				transparencytween:Play()
			end
		else
			warn(shape.." is not a valid shape.")
		end
	end
end
local upperbaroffset = 0
rs.RenderStepped:Connect(function()
	for i,v in pairs(gui.HelpMenu.BG.UpdateList.MouseFrame.ListCrop.ListContent:GetChildren()) do
		local frame = gui.HelpMenu.BG.UpdateList.MouseFrame.ListCrop.ListBG:FindFirstChild(v.Name)
		if frame then
			v.Position = UDim2.new(0,0,0,frame:WaitForChild("Pos").Value+gui.UpdateScroll.Value)
		end
	end
	
	if inputs.MouseEnabled == false and inputs.KeyboardEnabled == false and inputs.TouchEnabled == true then
		thumbstickframe = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("TouchGui"):FindFirstChild("TouchControlFrame"):FindFirstChild("DynamicThumbstickFrame")
		if not thumbstickframe then
			thumbstickframe = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("TouchGui"):FindFirstChild("TouchControlFrame"):FindFirstChild("ThumbstickFrame")
		end
		if thumbstickframe then
			if mouse.Y > (thumbstickframe.AbsolutePosition.Y-thumbstickframe.AbsoluteSize.Y)*-1 and mouse.X < thumbstickframe.AbsolutePosition.X+thumbstickframe.AbsoluteSize.X then
				isonthumbstick = true
			else
				isonthumbstick  =true
			end
		end
	end
	
	local t3 = namegui.LowerHalf.FormName.TextColor3
	local ts3 = namegui.LowerHalf.FormName.TextStrokeColor3
	
	upperbaroffset += 2
	if upperbaroffset > gui.UpperBar.Labeller.TextBounds.X then
		upperbaroffset = 0
	end
	gui.UpperBar.Offsetter.Position = UDim2.new(0,-gui.UpperBar.Labeller.TextBounds.X+upperbaroffset,0,0)
	gui.UpperBar.Labeller.Text = "|╫|  LAST ★ STAR // "..script.Values.CurrentForm.Value.." // "..string.upper(game:GetService("Players").LocalPlayer.Name).."  |╫|            "
	gui.UpperBar.BorderColor3 = ts3
	gui.UpperBar.BackgroundColor3 = t3
	gui.UpperBar.Shade.BackgroundColor3 = ts3
	gui.UpperBar.Glow.BackgroundColor3 = ts3
	gui.HelpButton.TextColor3 = t3
	gui.HelpButton.TextStrokeColor3 = ts3
	for i,v in pairs(gui.UpperBar.Offsetter:GetChildren()) do
		if v:IsA("TextLabel") then
			v.Text = gui.UpperBar.Labeller.Text
			v.Size = UDim2.new(0,gui.UpperBar.Labeller.TextBounds.X,1,0)
			v.TextStrokeColor3 = ts3
			v.TextColor3 = t3
		end
	end
	
	gui.Music.BorderColor3 = t3
	gui.Music.Bar.BackgroundColor3 = ts3
	gui.Music.Bar.Glow1.BackgroundColor3 = ts3
	gui.Music.HighLight.BackgroundColor3 = ts3
	gui.Music.HighLight.Glow1.BackgroundColor3 = ts3
	gui.Music.CurrentTime.TextColor3 = t3
	gui.Music.CurrentTime.TextStrokeColor3 = ts3
	gui.Music.Length.TextColor3 = t3
	gui.Music.Length.TextStrokeColor3 = ts3
	gui.Music.SongName.TextColor3 = t3
	gui.Music.SongName.TextStrokeColor3 = ts3
	
	local s = workspace.Camera.ViewportSize.Y/700
	gui.FormSelection.Size = UDim2.new(0,650*s*gui.WheelSize.Value,0,650*s*gui.WheelSize.Value)
	
	local lerp = .3
	gui.SpinBase.Position = UDim2.new(1,-40*s,1,-40*s)
	gui.SpinBase.Size = gui.SpinBase.Size:Lerp(UDim2.new(0,400*s+((theme.PlaybackLoudness/4))*theme.PlaybackSpeed*s,0,400*s+((theme.PlaybackLoudness/4))*theme.PlaybackSpeed*s),.5)
	gui.SpinBase.Spin1.ImageColor3 = t3
	gui.SpinBase.Spin2.ImageColor3 = ts3
	gui.SpinBase.Spin2.Gradient.ImageColor3 = t3
	gui.SpinBase.Spin3.ImageColor3 = ts3
	gui.SpinBase.Spin4.ImageColor3 = t3
	gui.SpinBase.Spin4.Gradient.ImageColor3 = ts3
	gui.SpinBase.Spin5.ImageColor3 = ts3
	gui.SpinBase.Spin6.ImageColor3 = ts3
	gui.SpinBase.Spin6.Gradient.ImageColor3 = t3
	gui.SpinBase.Spin7.ImageColor3 = t3
	local modifier = 400*s+((theme.PlaybackLoudness/4))*theme.PlaybackSpeed*s
	gui.SpinBase.Spin1.Rotation = gui.SpinBase.Spin1.Rotation + 1*(theme.PlaybackLoudness/100*(theme.Volume))*2*theme.PlaybackSpeed*modifier/gui.SpinBase.Size.Y.Offset
	gui.SpinBase.Spin2.Rotation = gui.SpinBase.Spin2.Rotation + -1.1*(theme.PlaybackLoudness/100*(theme.Volume))*2*theme.PlaybackSpeed*modifier/gui.SpinBase.Size.Y.Offset
	gui.SpinBase.Spin3.Rotation = gui.SpinBase.Spin3.Rotation + 1.6*(theme.PlaybackLoudness/100*(theme.Volume))*2*theme.PlaybackSpeed*modifier/gui.SpinBase.Size.Y.Offset
	gui.SpinBase.Spin4.Rotation = gui.SpinBase.Spin4.Rotation + -1.3*(theme.PlaybackLoudness/100*(theme.Volume))*2*theme.PlaybackSpeed*modifier/gui.SpinBase.Size.Y.Offset
	gui.SpinBase.Spin5.Rotation = gui.SpinBase.Spin5.Rotation + 1.3*(theme.PlaybackLoudness/100*(theme.Volume))*2*theme.PlaybackSpeed*modifier/gui.SpinBase.Size.Y.Offset
	gui.SpinBase.Spin6.Rotation = gui.SpinBase.Spin6.Rotation + -.8*(theme.PlaybackLoudness/100*(theme.Volume))*2*theme.PlaybackSpeed*modifier/gui.SpinBase.Size.Y.Offset
	
	gui.SettingsMenu.BackgroundColor3 = t3
	gui.SettingsMenu.BorderColor3 = ts3
	for i,v in pairs(gui.SettingsMenu:GetDescendants()) do
		if v:IsA("TextButton") or v:IsA("TextBox") or v:IsA("TextLabel") then
			v.TextStrokeColor3 = ts3
			v.TextColor3 = t3
			v.BackgroundColor3 = t3
			v.BorderColor3 = ts3
			v.BorderSizePixel = 5*s
		elseif v.Name == "Glow" then
			v.BackgroundColor3 = ts3
		elseif v.Name == "Glow1" then
			v.ImageColor3 = ts3
		end
	end
	gui.SettingsMenu.BorderSizePixel = 5*s
	gui.Music.BorderSizePixel = 5*s
	
	for i,v in pairs(gui.MobileAttacks:GetChildren()) do
		v.BackgroundColor3 = t3
		local r,g,b = 255-ts3.R*255,255-ts3.G*255,255-ts3.B*255
		local c3 = Color3.fromRGB(ts3.R*255+(r/4+r/4*math.cos(sine/-10))*v.Border.Value,ts3.G*255+(g/4+g/4*math.cos(sine/-10))*v.Border.Value,ts3.B*255+(b/4+b/4*math.cos(sine/-10))*v.Border.Value)
		v.BorderColor3 = c3
		v.BorderSizePixel = 5+(10+5*math.cos(sine/10))*v.Border.Value*s
		v.TextLabel.TextColor3 = t3
		v.TextLabel.TextStrokeColor3 = ts3
		v.AnchorPoint = Vector2.new(0.05+.05*math.cos(sine/(35+i*2)),.1+.1*math.cos(sine/(40+i*2)))
		v.Rotation = 1*math.cos(sine/(50+i*2))
		v.Glow.BackgroundColor3 = ts3
		v.Glow2.BackgroundColor3 = ts3
	end
	for i,v in pairs(gui.Visualiser.Base:GetChildren()) do
		if v:IsA("Frame") then
			v.Power.Value += 1
			v.Size = v.Size:Lerp(UDim2.new(0,theme.PlaybackLoudness*s*.5*theme.PlaybackSpeed*theme.Volume/1.5*(.75+.25*math.cos(v.Power.Value/15)),0.015,0),.3)
			v.UIGradient.Color = ColorSequence.new({ColorSequenceKeypoint.new(0,ts3),ColorSequenceKeypoint.new(1,t3)})
		end
	end
	for i,v in pairs({gui.MobileFormChange,gui.MobileSongMute}) do
		v.BorderColor3 = ts3
		v.BackgroundColor3 = t3
		v.TextStrokeColor3 = ts3
		v.TextColor3 = t3
		v.BorderSizePixel = 5*s
		v.Glow.BackgroundColor3 = ts3
		v.Glow1.BackgroundColor3 = ts3
	end
	for i,v in pairs(gui.Stats:GetDescendants()) do
		if v:IsA("TextLabel") then
			v.TextStrokeColor3 = ts3
			v.TextColor3 = t3
			v.BackgroundColor3 = t3
		elseif v:IsA("Frame") then
			v.BackgroundColor3 = ts3
		end
	end
	if script.Parent.Parent:FindFirstChild("Humanoid") then
		gui.Stats.Jump.Text = "JP / "..script.Parent.Parent.Humanoid.JumpPower
		gui.Stats.Speed.Text = "SP / "..script.Parent.Parent.Humanoid.WalkSpeed
		gui.Stats.Atk.Text = "ATK / X"..script.Parent.Values.Attack.Value
	end
	
	offset = 0
	if theme.SoundId == "rbxassetid://6399708347" then
		offset = 66
	elseif theme.SoundId == "rbxassetid://147420686" then
		offset = 1
	end
	
	gui.Music.Bar.Size = UDim2.new(theme.TimePosition/(theme.TimeLength-offset),0,1,0)
	gui.Music.CurrentTime.Text = transform(theme.TimePosition)
	gui.Music.Length.Text = transform(theme.TimeLength-offset)
	
	gui.Music.HighLight.Size = UDim2.new((gui.Music.AbsolutePosition.X-mouse.X)*-1/gui.Music.AbsoluteSize.X,0,1,0)
	
	if workspace:FindFirstChild("Chaos Spire") then
		local mag =( workspace["Chaos Spire"].Speen.Crystal.Position-workspace.CurrentCamera.CFrame.Position).Magnitude
		local y = math.clamp(mag,0,3000)
		local x =  math.clamp(mag/3000,0,1)
		for i,v in ipairs({workspace.SpireDistortion,workspace.SpireDistortionB,workspace.SpireDistortionC}) do
			if v.IsPlaying == false then
				v:Play()
			end
			v.Volume = 1-x
			if i == 3 then
				v.Volume = v.Volume*1.5
			end
		end
		if plr:FindFirstChild("HumanoidRootPart") then
			local mag2 =( workspace["Chaos Spire"].Speen.Crystal.Position-plr.HumanoidRootPart.Position).Magnitude
			if mag2 < 1000 then
				local vel = Instance.new("BodyVelocity",plr.HumanoidRootPart)
				vel.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
				vel.Velocity = CFrame.new(plr.HumanoidRootPart.Position,workspace["Chaos Spire"].Speen.Crystal.Position).LookVector.Unit*-3000
				game:GetService("Debris"):AddItem(vel,.1)
				for i,v in pairs({workspace.Shock1,workspace.Shock2,workspace.Shock3,workspace.Shock4}) do
					v.TimePosition = 0
					v:Play()
				end
				local cf = CFrame.new(workspace["Chaos Spire"].Speen.Crystal.Position)
				effect("Sphere",cf,Vector3.new(2000,2000,2000),Color3.fromRGB(255,0,0),Enum.Material.ForceField,0,2,Enum.EasingStyle.Quint,Enum.EasingDirection.Out,false,{Size=Vector3.new(2048,2048,2048)},1,Enum.EasingStyle.Linear)
				effect("Sphere",cf,Vector3.new(2000,2000,2000),Color3.fromRGB(255,0,0),Enum.Material.ForceField,0,1,Enum.EasingStyle.Quint,Enum.EasingDirection.Out,false,{Size=Vector3.new(2000,2000,2000)},1,Enum.EasingStyle.Sine)
				effect("Sphere",cf,Vector3.new(2000,2000,2000),Color3.fromRGB(255,0,0),Enum.Material.ForceField,0,2,Enum.EasingStyle.Quint,Enum.EasingDirection.Out,false,{Size=Vector3.new(1900,1900,1900)},1,Enum.EasingStyle.Linear)
			end
		end
		local ft = {"Arcade","Antique","SciFi","Bodoni","Garamond","Oswald","Arial","Bangers","Cartoon","Code","Creepster","DenkOne","Fantasy","Fondamento","FredokaOne","GothamSemibold","GrenzeGotisch","Highway","IndieFlower","JosefinSans","Jura","Kalam","LuckiestGuy","Merriweather","Michroma","Nunito","PatrickHand","PermanentMarker","RobotoMono","Sarpanch","SourceSansSemibold","SpecialElite","Ubuntu","TitilliumWeb"}
		gui.Worthy.Size = UDim2.new(math.random(25,100)/100,0,.2,0)
		gui.Worthy.Font = ft[math.random(1,#ft)]
		gui.Worthy.Rotation = math.random(-5,5)
		gui.Worthy.TextTransparency = x
		gui.Worthy.TextStrokeTransparency = x
		gui.Worthy.AnchorPoint = Vector2.new(math.random(40,60)/100,math.random(40,60)/100)
		local t = {"YOU ARE NOT WORTHY.","ARE YOU WORTHY?","YOU ARE NOT WORTHY?","?????????????????????","AAAAAAAAAAAAAAAAAAAAA","GET OUT","YOU ARE NOT","YOU ARE NOT WELCOME HERE."}
		gui.Worthy.Text = t[math.random(1,#t)]
		workspace.CurrentCamera.CFrame = workspace.CurrentCamera.CFrame*CFrame.Angles(math.rad(math.random(-5,5)*(1-x)),math.rad(math.random(-5,5)*(1-x)),math.rad(math.random(-5,5)*(1-x)))
		game:GetService("Lighting").ChaosSpireColorCorrection.TintColor = Color3.fromRGB(255,255*x,255*x)
		game:GetService("Lighting").ChaosSpireColorCorrection.Contrast = 0-(2*(1-x))
		game:GetService("Lighting").ChaosSpireColorCorrection.Brightness = math.random(-50,0)/100*(1-x)
	end
	
	for i,v in pairs(gui.FormSelection:GetDescendants()) do
		if v:IsA("TextButton") and v.Parent.Name ~= "Switch" then
			v.Parent.Marble.Inner.ImageColor3 = v.TextStrokeColor3
			if v.Text == "EXECUTION" or v.Text == "RAINBOW" then
				v.TextStrokeColor3 = c3(255,255,255)
				v.TextColor3 = script.Dynamics.Execution.Value
				v.Parent.ImageColor3 = script.Dynamics.Execution.Value
				v.Parent.Marble.ImageColor3 =  script.Dynamics.Execution.Value
				v.Parent.Marble.Inner.ImageColor3 = c3(255,255,255)
				v.Parent.Marble.Inner.Pattern.ImageColor3 = c3(255,255,255)
			elseif v.Text == "STIGMA" then
				v.TextStrokeColor3 = script.Dynamics.Execution.Value
				v.TextColor3 = c3(0,0,0)
				v.Parent.ImageColor3 = script.Dynamics.Execution.Value
				v.Parent.Marble.ImageColor3 =  script.Dynamics.Execution.Value
				v.Parent.Marble.Inner.ImageColor3 = c3(0,0,0)
				v.Parent.Marble.Inner.Pattern.ImageColor3 = c3(0,0,0)
			elseif v.Text == "SPECTRAFIELD" then
				v.TextStrokeColor3 = script.Dynamics.Spectrafield.Value
				v.TextColor3 = c3(255,255,255)
				v.Parent.ImageColor3 = script.Dynamics.Spectrafield.Value
				v.Parent.Marble.ImageColor3 =  script.Dynamics.Spectrafield.Value
				v.Parent.Marble.Inner.ImageColor3 = c3(255,255,255)
				v.Parent.Marble.Inner.Pattern.ImageColor3 = c3(255,255,255)
			elseif v.Text == "TURMOIL" then
				v.TextStrokeColor3 = script.Dynamics.Execution.Value
				v.TextColor3 = c3(0,0,0)
				v.Parent.ImageColor3 = script.Dynamics.Execution.Value
				v.Parent.Marble.ImageColor3 = c3(0,0,0)
				v.Parent.Marble.Inner.ImageColor3 = script.Dynamics.Execution.Value
				v.Parent.Marble.Inner.Pattern.ImageColor3 = script.Dynamics.Execution.Value
			elseif v.Text == "NEBULA" then
				p = script.Dynamics.NebulaA.Value
				s = script.Dynamics.NebulaB.Value
				v.TextStrokeColor3 = p
				v.TextColor3 = s
				v.Parent.ImageColor3 = p
				v.Parent.Marble.ImageColor3 = p
				v.Parent.Marble.Inner.ImageColor3 = s
				v.Parent.Marble.Inner.Pattern.ImageColor3 = s
			elseif v.Text == "AURORA" then
				p = script.Dynamics.Aurora.Value
				v.TextStrokeColor3 = p
				v.TextColor3 = Color3.fromRGB(255,255,255)
				v.Parent.ImageColor3 = p
				v.Parent.Marble.ImageColor3 = Color3.fromRGB(255,255,255)
				v.Parent.Marble.Inner.ImageColor3 = p
				v.Parent.Marble.Inner.Pattern.ImageColor3 = p
			elseif v.Text == "CHAOS" then
				local bc = BrickColor.Random().Color
				p = Color3.new(bc.R,bc.G,bc.B)
				s = Color3.fromRGB(27,42,53)
				v.TextStrokeColor3 = p
				v.TextColor3 = s
				v.Parent.ImageColor3 = p
				v.Parent.Marble.ImageColor3 = p
				v.Parent.Marble.Inner.ImageColor3 = s
				v.Parent.Marble.Inner.Pattern.ImageColor3 = s
			elseif v.Text == "SHATTERED" then
				p =  Color3.fromHSV(math.random(1,360)/360,1,1)
				s = Color3.fromRGB(0,0,0)
				v.TextStrokeColor3 = s
				v.TextColor3 = p
				v.Parent.ImageColor3 = p
				v.Parent.Marble.ImageColor3 = s
				v.Parent.Marble.Inner.ImageColor3 = p
				v.Parent.Marble.Inner.Pattern.ImageColor3 = p
			elseif v.Text == "DISSONANCE" then
				local p = Color3.fromHSV(math.random(230,290)/360,math.random(70,100)/100,math.random(10,70)/100)
				local s = Color3.fromHSV(math.random(230,290)/360,math.random(70,100)/100,math.random(10,70)/100)
				v.TextStrokeColor3 = p
				v.TextColor3 = s
				v.Parent.ImageColor3 = p
				v.Parent.Marble.ImageColor3 = p
				v.Parent.Marble.Inner.ImageColor3 = s
				v.Parent.Marble.Inner.Pattern.ImageColor3 = s
			elseif v.Text == "DISTORTION" then
				local p = Color3.fromHSV(0,1,math.random(0,100)/100)
				local s = Color3.fromHSV(0,1,math.random(0,100)/100)
				v.TextStrokeColor3 = p
				v.TextColor3 = s
				v.Parent.ImageColor3 = p
				v.Parent.Marble.ImageColor3 = s
				v.Parent.Marble.Inner.ImageColor3 = p
				v.Parent.Marble.Inner.Pattern.ImageColor3 = p
			elseif v.Text == "MISMATCHED" then
				local x = Color3.fromHSV(0,0,math.random(1,100)/100)
				local z = Color3.fromRGB(255-x.R*255,255-x.G*255,255-x.B*255)
				v.TextStrokeColor3 = z
				v.TextColor3 = x
				v.Parent.ImageColor3 = x
				v.Parent.Marble.ImageColor3 = x
				v.Parent.Marble.Inner.ImageColor3 = z
				v.Parent.Marble.Inner.Pattern.ImageColor3 = z
			elseif v.Text == "VOID" then
				p = Color3.fromHSV(0.75+0.015*math.cos(sine/8), 1, 1)
				s = Color3.new(0.027451, 0, 0.0431373)
				v.TextStrokeColor3 = p
				v.TextColor3 = s
				v.Parent.ImageColor3 = p
				v.Parent.Marble.ImageColor3 = p
				v.Parent.Marble.Inner.ImageColor3 = s
				v.Parent.Marble.Inner.Pattern.ImageColor3 = s
			elseif v.Text == "PERDURANCE" then
				local g = 0.85+0.15*math.cos(sine/20)
				local u = script.Parent.Dynamics.Perdurance.Value
				p = Color3.new(u.R*g,u.G*g,u.B*g)
				s = Color3.new(u.R*.15,u.G*.15,u.B*.15)
				v.TextStrokeColor3 = p
				v.TextColor3 = s
				v.Parent.ImageColor3 = p
				v.Parent.Marble.ImageColor3 = p
				v.Parent.Marble.Inner.ImageColor3 = s
				v.Parent.Marble.Inner.Pattern.ImageColor3 = s
			elseif v.Text == "REVOLUTION" then
				local ft = {"Arcade","Antique","SciFi","Bodoni","Garamond","Oswald","Arial","Bangers","Cartoon","Code","Creepster","DenkOne","Fantasy","Fondamento","FredokaOne","GothamSemibold","GrenzeGotisch","Highway","IndieFlower","JosefinSans","Jura","Kalam","LuckiestGuy","Merriweather","Michroma","Nunito","PatrickHand","PermanentMarker","RobotoMono","Sarpanch","SourceSansSemibold","SpecialElite","Ubuntu","TitilliumWeb"}
				v.Font = ft[math.random(1,#ft)]
			elseif v.Text == "INFERNO" then
				p = Color3.fromHSV(0.0696944, 0.909804, math.random(75,100)*0.01)
				s = Color3.new(0.0588235, 0.0588235, 0.0784314)
				v.TextStrokeColor3 = s
				v.TextColor3 = p
				v.Parent.ImageColor3 = p
				v.Parent.Marble.ImageColor3 = p
				v.Parent.Marble.Inner.ImageColor3 = s
				v.Parent.Marble.Inner.Pattern.ImageColor3 = s
			elseif v.Parent.ID.Value == "NIHIL" then
				p = Color3.fromHSV(240/360,math.random(0,100)/100,math.random(0,100)/100)
				s = Color3.fromHSV(240/360,math.random(0,100)/100,math.random(0,100)/100)
				v.TextStrokeColor3 = s
				v.TextColor3 = p
				v.Parent.ImageColor3 = p
				v.Parent.Marble.ImageColor3 = p
				local n,i,h,l = {"N","n"},{"I","i"},{"H","h"},{"L","l"}
				v.Text = n[math.random(1,2)]..i[math.random(1,2)]..h[math.random(1,2)]..i[math.random(1,2)]..l[math.random(1,2)]
				local ft = {"Arcade","Antique","SciFi","Bodoni","Garamond","Oswald","Arial","Bangers","Cartoon","Code","Creepster","DenkOne","Fantasy","Fondamento","FredokaOne","GothamSemibold","GrenzeGotisch","Highway","IndieFlower","JosefinSans","Jura","Kalam","LuckiestGuy","Merriweather","Michroma","Nunito","PatrickHand","PermanentMarker","RobotoMono","Sarpanch","SourceSansSemibold","SpecialElite","Ubuntu","TitilliumWeb"}
				v.Font = ft[math.random(1,#ft)]
				v.Parent.Marble.Inner.ImageColor3 = s
				v.Parent.Marble.Inner.Pattern.ImageColor3 = s
			elseif v.Parent.ID.Value == "ABERRATION" then
				local ctable = {
					[1]={Color3.fromRGB(252, 226, 5);Color3.fromRGB(225, 225, 255)};
					[2]={Color3.fromRGB(155, 135, 12);Color3.fromRGB(0, 0, 0)};
					[3]={Color3.fromRGB(143, 139, 102);Color3.fromRGB(86, 86, 86)};
				}
				local ma = math.random(1,3)
				p = ctable[ma][1]
				s = ctable[ma][2]
				v.TextStrokeColor3 = p
				v.TextColor3 = s
				v.Parent.ImageColor3 = p
				v.Parent.Marble.ImageColor3 = s
				v.Parent.Marble.Inner.ImageColor3 = p
				v.Parent.Marble.Inner.Pattern.ImageColor3 = p
			elseif v.Parent.ID.Value == "ANOMALY" then
				p = Color3.fromHSV(0,math.random(0,100)/100,math.random(0,100)/100)
				s = Color3.fromHSV(0,math.random(0,100)/100,math.random(0,100)/100)
				v.TextStrokeColor3 = s
				v.TextColor3 = p
				v.Parent.ImageColor3 = p
				v.Parent.Marble.ImageColor3 = p
				v.Parent.Marble.Inner.ImageColor3 = s
				v.Parent.Marble.Inner.Pattern.ImageColor3 = s
			elseif v.Parent.ID.Value == "TERMINATION" then
				p = Color3.fromHSV(120/360,math.random(0,100)/100,math.random(0,100)/100)
				s = Color3.fromHSV(120/360,math.random(0,100)/100,math.random(0,100)/100)
				local t,e,r,m,i,n,a,o,n = {"T","t"},{"E","e"},{"R","r"},{"M","m"},{"I","i"},{"N","n"},{"A","a"},{"O","o"},{"N","n"}
				v.TextStrokeColor3 = s
				v.TextColor3 = p
				v.Parent.ImageColor3 = p
				v.Parent.Marble.ImageColor3 = p
				v.Text = t[math.random(1,2)]..e[math.random(1,2)]..r[math.random(1,2)]..m[math.random(1,2)]..i[math.random(1,2)]..n[math.random(1,2)]..a[math.random(1,2)]..t[math.random(1,2)]..i[math.random(1,2)]..o[math.random(1,2)]..n[math.random(1,2)]
				v.Parent.Marble.Inner.ImageColor3 = s
				v.Parent.Marble.Inner.Pattern.ImageColor3 = s
			elseif v.Parent.ID.Value == "404" then
				local x = math.random(1,3)
				local under  = {"","_",}
				if x > 1 then
					v.Text = "404"..under[math.random(1,#under)]
					p = Color3.fromRGB(47, 78, 255)
					s = Color3.fromRGB(24, 40, 130)
				else
					local under  = {"","_","_?","_!","!"}
					v.Text = under[math.random(1,#under)]..under[math.random(1,#under)]..under[math.random(1,#under)].."???"
					p = Color3.fromRGB(0,0,0)
					s = Color3.fromRGB(255,255,255)
				end
				v.TextStrokeColor3 = p
				v.TextColor3 = s
				v.Parent.ImageColor3 = p
				v.Parent.Marble.ImageColor3 = s
				v.Parent.Marble.Inner.ImageColor3 = p
				v.Parent.Marble.Inner.Pattern.ImageColor3 = p
			elseif v.Parent.ID.Value == "SYSTEM_" then
				p = Color3.fromHSV(0,1,math.random(0,100)/100)
				s = Color3.fromHSV(0,1,math.random(0,100)/100)
				local ntable = {"SYSTEM_","SYSTEM_LOST","SYSTEM_EXCEPTION","SYSTEM_NULL","SYSTEM_CRASH","SYSMTE_SHUTDOWN","SYSTEM_DELETED","SYSTEM_NOT_FOUND","SYSTEM_FATALITY","SYSTEM_???","SYSTEM_ERROR","SYSTEM_CORRUPTED","SYSTEM_FAILURE","SYSTEM_UNKNOWN"}
				v.TextStrokeColor3 = s
				v.TextColor3 = p
				v.Parent.ImageColor3 = p
				v.Parent.Marble.ImageColor3 = p
				v.Text = ntable[math.random(1,#ntable)]
				v.Parent.Marble.Inner.ImageColor3 = s
				v.Parent.Marble.Inner.Pattern.ImageColor3 = s
			elseif v.Parent.ID.Value == "ALTERATION" then
				p = Color3.fromHSV(0,0,math.random(1,100)/100)
				s = Color3.fromHSV(0,0,math.random(1,100)/100)
				v.TextStrokeColor3 = s
				v.TextColor3 = p
				v.Parent.ImageColor3 = p
				v.Parent.Marble.ImageColor3 = p
				v.Parent.Marble.Inner.ImageColor3 = s
					v.Parent.Marble.Inner.Pattern.ImageColor3 = s
			elseif v.Parent.ID.Value == "ALACRITY" then
				v.TextStrokeColor3 = Color3.fromRGB(255,200,50)
				v.TextColor3 = Color3.fromRGB(0,200,0)
				v.Parent.ImageColor3 = Color3.fromRGB(0,200,0)
				v.Parent.Marble.ImageColor3 = Color3.fromRGB(0,200,0)
				v.Parent.Marble.Inner.ImageColor3 = Color3.fromRGB(255,200,50)
				v.Parent.Marble.Inner.Pattern.ImageColor3 = Color3.fromRGB(255,200,50)
			elseif v.Parent.ID.Value == "INTRICACY" then
				v.TextStrokeColor3 = Color3.fromRGB(255,255,555)
				v.TextColor3 = Color3.fromRGB(0,255,0)
				v.Parent.ImageColor3 = Color3.fromRGB(0,255,0)
				v.Parent.Marble.ImageColor3 = Color3.fromRGB(255,255,555)
				v.Parent.Marble.Inner.ImageColor3 = Color3.fromRGB(0,255,0)
				v.Parent.Marble.Inner.Pattern.ImageColor3 = Color3.fromRGB(100,255,100)
			elseif v.Text == "" then
				v.Parent.ImageColor3 = c3(20,20,20)
			else
				v.TextStrokeColor3 = v.Parent.Primary.Value
				v.TextColor3 = v.Parent.Secondary.Value
				v.Parent.ImageColor3 = v.Parent.Primary.Value
				v.Parent.Marble.ImageColor3 = v.TextColor3
				v.Parent.Marble.Inner.ImageColor3 = v.TextStrokeColor3
				v.Parent.Marble.Inner.Pattern.ImageColor3 = v.TextStrokeColor3
			end
		end
	end
	
end)

local menuinfo = TweenInfo.new(.3,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0,false,0)
local m1,m2 = {AnchorPoint = Vector2.new(0,.5)},{AnchorPoint = Vector2.new(.8,.5)}
local mt1,mt2 = tweens:Create(gui.SettingsMenu,menuinfo,m1),tweens:Create(gui.SettingsMenu,menuinfo,m2)

gui.SettingsMenu.MouseEnter:Connect(function()
	if inputs.MouseEnabled == true and inputs.KeyboardEnabled == true and inputs.TouchEnabled == false then
		mt1:Play()
	end
end)
gui.SettingsMenu.MouseLeave:Connect(function()
	if inputs.MouseEnabled == true and inputs.KeyboardEnabled == true and inputs.TouchEnabled == false then
		mt2:Play()
	end
end)

local open = false
gui.SettingsMenu.MouseButton1Click:Connect(function()
	if inputs.MouseEnabled == false and inputs.KeyboardEnabled == false and inputs.TouchEnabled == true then
		if open == false then
			open = true
			mt1:Play()
		else
			open = false
			mt2:Play()
		end
	end
end)

gui.SettingsMenu.EffectLimit.Changed:Connect(function(change)
	if change == "Text" then
		local ef = gui.SettingsMenu.EffectLimit
		if tonumber(ef.Text) then
			plr.LastStar.Settings.EffectLimit.Value = tonumber(ef.Text)
		else
			plr.LastStar.Settings.EffectLimit.Value = tonumber(0)
		end
	end
end)

gui.SettingsMenu.Aura.MouseButton1Click:Connect(function()
	if gui.SettingsMenu.Aura.Text == "All" then
		gui.SettingsMenu.Aura.Text = "You"
		plr.LastStar.Settings.Auras.Value = "You"
	elseif gui.SettingsMenu.Aura.Text == "You" then
		gui.SettingsMenu.Aura.Text = "None"
		plr.LastStar.Settings.Auras.Value = "None"
	else
		gui.SettingsMenu.Aura.Text = "All"
		plr.LastStar.Settings.Auras.Value = "All"
	end
end)

gui.SettingsMenu.Chat.MouseButton1Click:Connect(function()
	if gui.SettingsMenu.Chat.Text == "Typewriter" then
		gui.SettingsMenu.Chat.Text = "Instant"
		plr.LastStar.Settings.ChatType.Value = "Instant"
	elseif gui.SettingsMenu.Chat.Text == "Instant" then
		gui.SettingsMenu.Chat.Text = "Simple"
		plr.LastStar.Settings.ChatType.Value = "Simple"
	else
		gui.SettingsMenu.Chat.Text = "Typewriter"
		plr.LastStar.Settings.ChatType.Value = "Typewriter"
	end
end)

gui.SettingsMenu.Camshake.MouseButton1Click:Connect(function()
	if gui.SettingsMenu.Camshake.Text == "On" then
		gui.SettingsMenu.Camshake.Text = "Off"
		plr.LastStar.Settings.Camshake.Value = 0
	else
		gui.SettingsMenu.Camshake.Text = "On"
		plr.LastStar.Settings.Camshake.Value = 1
	end
end)

gui.Music.Button.MouseButton1Click:Connect(function()
	script.Parent.Events.MusicRemote:FireServer((theme.TimeLength-offset)*(gui.Music.AbsolutePosition.X-mouse.X)*-1/gui.Music.AbsoluteSize.X)
end)

coroutine.resume(coroutine.create(function()
	while true do
		wait()
		gui.FormSelection.Rotation += .1
		for i,v in pairs(gui.FormSelection:GetDescendants()) do
			if v.Name == "Marble" then
				v.Rotation -= .1
			end
		end
		gui.FormSelection.BackButton.Label.Rotation -= .1
		gui.FormSelection.Shade.Rotation -= .1
	end
end))

local info = TweenInfo.new(.2,Enum.EasingStyle.Sine,Enum.EasingDirection.Out,0,false,0)
local info2 = TweenInfo.new(.2,Enum.EasingStyle.Sine,Enum.EasingDirection.In,0,false,0)
local prop1,prop2 = {Value=1},{Value=0}
local tween1,tween2 = tweens:Create(gui.WheelSize,info,prop1),tweens:Create(gui.WheelSize,info2,prop2)
local showingwheel = false
inputs.InputBegan:Connect(function(key,aaa)
	if not aaa then
		if key.UserInputType == Enum.UserInputType.Keyboard then
			if key.KeyCode == Enum.KeyCode.E then
				if showingwheel == false then
					tween1:Play()
					showingwheel = true
				else
					tween2:Play()
					showingwheel = false
				end
			end
		end
	end
end)

gui.MobileSongMute.MouseButton1Click:Connect(function()
	script.Parent.Events.Key:FireServer(Enum.KeyCode.L,"on")
end)
gui.MobileFormChange.MouseButton1Click:Connect(function()
	if showingwheel == false then
		tween1:Play()
		showingwheel = true
	else
		tween2:Play()
		showingwheel = false
	end
end)
local sliceinfo = TweenInfo.new(.1,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut,0,false,0)
local p1,p2 = {Size=UDim2.new(1.1,0,1.1,0)},{Size=UDim2.new(1,0,1,0)}
local p3,p4 = {Size=UDim2.new(.1,0,.1,0)},{Size=UDim2.new(.07,0,.07,0)}

local hinfo = TweenInfo.new(.4,Enum.EasingStyle.Circular,Enum.EasingDirection.Out,0,false,0)
local switchedcolour = Color3.fromRGB(0,0,0)
for i,v in pairs(gui.FormSelection:GetChildren()) do
	if v:IsA("ImageLabel") then
		
		local prop = {ImageTransparency=1}
		local tween = tweens:Create(v:WaitForChild("Highlight"),hinfo,prop)
		v.ID.Changed:Connect(function()
			v.Highlight.ImageTransparency = 0
			tween:Play()
		end)
		
		local t1,t2 = tweens:Create(v,sliceinfo,p1),tweens:Create(v,sliceinfo,p2)
		v.TextButton.MouseEnter:Connect(function()
			t1:Play()
		end)
		v.TextButton.MouseLeave:Connect(function()
			t2:Play()
		end)
		v.TextButton.MouseButton1Click:Connect(function()
			if v.TextButton.Text ~= script.Parent.Values.CurrentForm.Value then
				script.Parent.Events.Switching:FireServer(v.ID.Value)
				switchedcolour = v.ImageColor3
				tween2:Play()
				showingwheel = false
			else
				script.Parent.Events.Switching:FireServer(v.ID.Value.."MAJORS")
			end
		end)
		local t3,t4 = tweens:Create(v.Marble,sliceinfo,p3),tweens:Create(v.Marble,sliceinfo,p4)
		v.Marble.MouseEnter:Connect(function()
			t3:Play()
		end)
		v.Marble.MouseLeave:Connect(function()
			t4:Play()
		end)
		v.Marble.MouseButton1Click:Connect(function()
			if v.TextButton.Text ~= script.Parent.Values.CurrentForm.Value then
				script.Parent.Events.Switching:FireServer(v.ID.Value)
				switchedcolour = v.ImageColor3
			end
			script.Parent.Events.Switching:FireServer(v.ID.Value.."ALTS")
		end)
	end
end
gui.FormSelection.BackButton.MouseButton1Click:Connect(function()
	script.Parent.Events.Switching:FireServer("GOBACK")
end)
local button = gui.FormSelection.Shade.Switch.Button

if game:GetService("Players").LocalPlayer.Name == "Asarii_IV" then
	gui.FormSelection.Shade.Switch.Visible=true
end

button.MouseButton1Click:Connect(function()
	if button.Text == "DISGRACE" then
		button.Text = "STANDARD"
		script.Parent.Events.Switching:FireServer("DISGRACE")
		script.Parent.Events.Switching:FireServer("DOWNFALL")
	else
		button.Text = "DISGRACE"
		script.Parent.Events.Switching:FireServer("BASE")
		script.Parent.Events.Switching:FireServer("APEX")
	end
end)


local sinfo = TweenInfo.new(.5,Enum.EasingStyle.Circular,Enum.EasingDirection.Out,0,false,0)
local sprop = {BackgroundTransparency=1}
local stween = tweens:Create(gui.SwitchShine,sinfo,sprop)
game:GetService("Players").LocalPlayer.Character:WaitForChild("Values"):WaitForChild("CurrentForm").Changed:Connect(function()
	gui.SwitchShine.BackgroundColor3 = switchedcolour
	gui.SwitchShine.BackgroundTransparency=0
	stween:Play()
end)

game:GetService("RunService").RenderStepped:Connect(function()
wait()
if script.Values:WaitForChild("WingStyle").Value == "VISUALISER" then
    local LocalLoudness = 0
	Loud,LocalLoudness = theme.PlaybackLoudness,math.ceil(Loud)
	script.Events.VisualizerEvent:FireServer(LocalLoudness)
end
end)

for i = 1,90 do
	local w = gui.Visualiser.Vis:Clone()
	w.Parent = gui.Visualiser.Base
	w.Visible=true
	w.Power.Value = i*1.5
end
for i = 1,20 do
	local l = gui.UpperBar.Labeller:Clone()
	l.Parent = gui.UpperBar.Offsetter
	l.Size = UDim2.new(0,gui.UpperBar.Labeller.TextBounds.X,1,0)
	l.Visible=true
end

while true do
	game:GetService("RunService").Heartbeat:Wait()
	sine += 1
	for i,v in pairs({gui.MobileSongMute,gui.MobileFormChange}) do
		v.AnchorPoint = Vector2.new(.95+.05*math.cos(sine/30+(i*4)),.5+.05*math.sin(sine/34+(i*6)))
		v.Rotation = 2*math.cos(sine/25+(i*7))
	end
	if aiming == false then
		gui.Music.AnchorPoint = gui.Music.AnchorPoint:Lerp(Vector2.new(0.025+0.025*math.cos(sine/33),.6+0.4*math.sin(sine/39)),.1)
		gui.Music.Rotation = 2*math.cos(sine/54)*(gui.Music.AnchorPoint.Y/.5)
	else
		gui.Music.AnchorPoint = gui.Music.AnchorPoint:Lerp(Vector2.new(0,.5),.1)
		gui.Music.Rotation = 2*math.cos(sine/54)*(1-(gui.Music.AnchorPoint.Y/.5))
	end
	gui.Music.CurrentTime.AnchorPoint = Vector2.new(0.025+0.025*math.cos(sine/29),.9+0.1*math.sin(sine/42))
	gui.Music.CurrentTime.Rotation = 2*math.cos(sine/62)
	gui.Music.Length.AnchorPoint = Vector2.new(9.975+0.025*math.cos(sine/25),.9+0.1*math.sin(sine/37))
	gui.Music.Length.Rotation = 2*math.cos(sine/60)
	gui.Music.SongName.AnchorPoint = Vector2.new(0.02+0.02*math.cos(sine/24.5),.2+0.2*math.sin(sine/45))
	gui.Music.SongName.Rotation = 2*math.cos(sine/55)
	for i,v in pairs(gui.Stats:GetChildren()) do
		v.Rotation = 2*math.cos(sine/60+(i*3))
		v.AnchorPoint = Vector2.new(.5+.05*math.cos(sine/45+(i*5)),.5+.2*math.cos(sine/55+(i*7)))
	end
end
end)
